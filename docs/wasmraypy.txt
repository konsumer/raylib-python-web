
import enum

# helper to copy a struct
# newColor = struct_clone(RAYWHITE)
# newColor._frozen = false
# newColor.a = 127


def struct_clone(source, a):
    if not a:
        a = _mod._malloc(source._size)
    _mod._memcpy(a, source._address, source._size)
    out = source.__class__(address=a)
    return out

class WasmArray:
    """Generic array-like collection that uses wasm as memory-back"""
    
    def __init__(self, item_size: int, length: int, address: int = 0):
        self._length = length
        self._item_size = item_size
        self._size = self._item_size * self._length
        if address != 0:
            self._address: int = address
            self._to_free: bool = False
        else:
            self._address: int = _mod._malloc(self._size)
            self._to_free: bool = True

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

    def __len__(self):
        return self._length

    def __str__(self):
        out = "WasmArray["
        out += ', '.join([str(self[i]) for i in range(self._length)])
        out += "] " + hex(self._address)
        return out


class StructArray(WasmArray):
    """an array of structs"""
    def __init__(self, stype, length, address: int = 0):
        super(StructArray, self).__init__(stype._size, length, address)
        self._stype = stype

    def __getitem__(self, item):
        return self._stype(address=(self._address + (self._item_size * item)))

    def __setitem__(self, item, value):
        struct_clone(value, self._address + (self._item_size * item))
    
class CharArray(WasmArray):
    def __init__(self, length, address: int = 0):
        super(CharArray, self).__init__(1, length, address)

    def __getitem__(self, item):
        return _mod.mem.getInt8(self._address + (item * self._item_size), True)

    def __setitem__(self, item, value):
        _mod.mem.setInt8(self._address + (item * self._item_size), value, True)


class UCharArray(WasmArray):
    def __init__(self, length, address: int = 0):
        super(UCharArray, self).__init__(1, length, address)

    def __getitem__(self, item):
        return _mod.mem.getUint8(self._address + (item * self._item_size), True)

    def __setitem__(self, item, value):
        _mod.mem.setUint8(self._address + (item * self._item_size), value, True)


class Int16Array(WasmArray):
    def __init__(self, length, address: int = 0):
        super(Int16Array, self).__init__(2, length, address)

    def __getitem__(self, item):
        return _mod.mem.getInt16(self._address + (item * self._item_size), True)

    def __setitem__(self, item, value):
        _mod.mem.setInt16(self._address + (item * self._item_size), value, True)


class UInt16Array(WasmArray):
    def __init__(self, length, address: int = 0):
        super(UInt16Array, self).__init__(2, length, address)

    def __getitem__(self, item):
        return _mod.mem.getUint16(self._address + (item * self._item_size), True)

    def __setitem__(self, item, value):
        _mod.mem.setUint16(self._address + (item * self._item_size), value, True)


class Int32Array(WasmArray):
    def __init__(self, length, address: int = 0):
        super(Int32Array, self).__init__(4, length, address)

    def __getitem__(self, item):
        return _mod.mem.getInt32(self._address + (item * self._item_size), True)

    def __setitem__(self, item, value):
        _mod.mem.setInt32(self._address + (item * self._item_size), value, True)


class UInt32Array(WasmArray):
    def __init__(self, length, address: int = 0):
        super(UInt32Array, self).__init__(4, length, address)

    def __getitem__(self, item):
        return _mod.mem.getUint32(self._address + (item * self._item_size), True)

    def __setitem__(self, item, value):
        _mod.mem.setUint32(self._address + (item * self._item_size), value, True)


class FloatArray(WasmArray):
    def __init__(self, length, address: int = 0):
        super(FloatArray, self).__init__(4, length, address)

    def __getitem__(self, item):
        return _mod.mem.getFloat32(self._address + (item * self._item_size), True)

    def __setitem__(self, item, value):
        _mod.mem.setFloat32(self._address + (item * self._item_size), value, True)


class DoubleArray(WasmArray):
    def __init__(self, length, address: int = 0):
        super(DoubleArray, self).__init__(8, length, address)

    def __getitem__(self, item):
        return _mod.mem.getFloat64(self._address + (item * self._item_size), True)

    def __setitem__(self, item, value):
        _mod.mem.setFloat64(self._address + (item * self._item_size), value, True)


class Vector2:
    """Vector2, 2 components"""

    _size: int = 8

    def __init__(self, x: float = 0.0, y: float = 0.0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(8)
            self._to_free = True
            _mod.mem.setFloat32(self._address + 0, x)
            _mod.mem.setFloat32(self._address + 4, y)

    @property
    def x(self):
        """Vector x component"""
        return _mod.mem.getFloat32(self._address + 0, True)

    @x.setter
    def x(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 0, value, True)

    @property
    def y(self):
        """Vector y component"""
        return _mod.mem.getFloat32(self._address + 4, True)

    @y.setter
    def y(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 4, value, True)

    def __str__(self):
        return f"Vector2(address={self._address}, {self.x}, {self.y})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Vector3:
    """Vector3, 3 components"""

    _size: int = 12

    def __init__(self, x: float = 0.0, y: float = 0.0, z: float = 0.0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(12)
            self._to_free = True
            _mod.mem.setFloat32(self._address + 0, x)
            _mod.mem.setFloat32(self._address + 4, y)
            _mod.mem.setFloat32(self._address + 8, z)

    @property
    def x(self):
        """Vector x component"""
        return _mod.mem.getFloat32(self._address + 0, True)

    @x.setter
    def x(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 0, value, True)

    @property
    def y(self):
        """Vector y component"""
        return _mod.mem.getFloat32(self._address + 4, True)

    @y.setter
    def y(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 4, value, True)

    @property
    def z(self):
        """Vector z component"""
        return _mod.mem.getFloat32(self._address + 8, True)

    @z.setter
    def z(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 8, value, True)

    def __str__(self):
        return f"Vector3(address={self._address}, {self.x}, {self.y}, {self.z})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Vector4:
    """Vector4, 4 components"""

    _size: int = 16

    def __init__(self, x: float = 0.0, y: float = 0.0, z: float = 0.0, w: float = 0.0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(16)
            self._to_free = True
            _mod.mem.setFloat32(self._address + 0, x)
            _mod.mem.setFloat32(self._address + 4, y)
            _mod.mem.setFloat32(self._address + 8, z)
            _mod.mem.setFloat32(self._address + 12, w)

    @property
    def x(self):
        """Vector x component"""
        return _mod.mem.getFloat32(self._address + 0, True)

    @x.setter
    def x(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 0, value, True)

    @property
    def y(self):
        """Vector y component"""
        return _mod.mem.getFloat32(self._address + 4, True)

    @y.setter
    def y(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 4, value, True)

    @property
    def z(self):
        """Vector z component"""
        return _mod.mem.getFloat32(self._address + 8, True)

    @z.setter
    def z(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 8, value, True)

    @property
    def w(self):
        """Vector w component"""
        return _mod.mem.getFloat32(self._address + 12, True)

    @w.setter
    def w(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 12, value, True)

    def __str__(self):
        return f"Vector4(address={self._address}, {self.x}, {self.y}, {self.z}, {self.w})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

Quaternion = Vector4

class Matrix:
    """Matrix, 4x4 components, column major, OpenGL style, right-handed"""

    _size: int = 64

    def __init__(self, m0: float = 0.0, m4: float = 0.0, m8: float = 0.0, m12: float = 0.0, m1: float = 0.0, m5: float = 0.0, m9: float = 0.0, m13: float = 0.0, m2: float = 0.0, m6: float = 0.0, m10: float = 0.0, m14: float = 0.0, m3: float = 0.0, m7: float = 0.0, m11: float = 0.0, m15: float = 0.0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(64)
            self._to_free = True
            _mod.mem.setFloat32(self._address + 0, m0)
            _mod.mem.setFloat32(self._address + 4, m4)
            _mod.mem.setFloat32(self._address + 8, m8)
            _mod.mem.setFloat32(self._address + 12, m12)
            _mod.mem.setFloat32(self._address + 16, m1)
            _mod.mem.setFloat32(self._address + 20, m5)
            _mod.mem.setFloat32(self._address + 24, m9)
            _mod.mem.setFloat32(self._address + 28, m13)
            _mod.mem.setFloat32(self._address + 32, m2)
            _mod.mem.setFloat32(self._address + 36, m6)
            _mod.mem.setFloat32(self._address + 40, m10)
            _mod.mem.setFloat32(self._address + 44, m14)
            _mod.mem.setFloat32(self._address + 48, m3)
            _mod.mem.setFloat32(self._address + 52, m7)
            _mod.mem.setFloat32(self._address + 56, m11)
            _mod.mem.setFloat32(self._address + 60, m15)

    @property
    def m0(self):
        """Matrix first row (4 components)"""
        return _mod.mem.getFloat32(self._address + 0, True)

    @m0.setter
    def m0(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 0, value, True)

    @property
    def m4(self):
        """Matrix first row (4 components)"""
        return _mod.mem.getFloat32(self._address + 4, True)

    @m4.setter
    def m4(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 4, value, True)

    @property
    def m8(self):
        """Matrix first row (4 components)"""
        return _mod.mem.getFloat32(self._address + 8, True)

    @m8.setter
    def m8(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 8, value, True)

    @property
    def m12(self):
        """Matrix first row (4 components)"""
        return _mod.mem.getFloat32(self._address + 12, True)

    @m12.setter
    def m12(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 12, value, True)

    @property
    def m1(self):
        """Matrix second row (4 components)"""
        return _mod.mem.getFloat32(self._address + 16, True)

    @m1.setter
    def m1(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 16, value, True)

    @property
    def m5(self):
        """Matrix second row (4 components)"""
        return _mod.mem.getFloat32(self._address + 20, True)

    @m5.setter
    def m5(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 20, value, True)

    @property
    def m9(self):
        """Matrix second row (4 components)"""
        return _mod.mem.getFloat32(self._address + 24, True)

    @m9.setter
    def m9(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 24, value, True)

    @property
    def m13(self):
        """Matrix second row (4 components)"""
        return _mod.mem.getFloat32(self._address + 28, True)

    @m13.setter
    def m13(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 28, value, True)

    @property
    def m2(self):
        """Matrix third row (4 components)"""
        return _mod.mem.getFloat32(self._address + 32, True)

    @m2.setter
    def m2(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 32, value, True)

    @property
    def m6(self):
        """Matrix third row (4 components)"""
        return _mod.mem.getFloat32(self._address + 36, True)

    @m6.setter
    def m6(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 36, value, True)

    @property
    def m10(self):
        """Matrix third row (4 components)"""
        return _mod.mem.getFloat32(self._address + 40, True)

    @m10.setter
    def m10(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 40, value, True)

    @property
    def m14(self):
        """Matrix third row (4 components)"""
        return _mod.mem.getFloat32(self._address + 44, True)

    @m14.setter
    def m14(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 44, value, True)

    @property
    def m3(self):
        """Matrix fourth row (4 components)"""
        return _mod.mem.getFloat32(self._address + 48, True)

    @m3.setter
    def m3(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 48, value, True)

    @property
    def m7(self):
        """Matrix fourth row (4 components)"""
        return _mod.mem.getFloat32(self._address + 52, True)

    @m7.setter
    def m7(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 52, value, True)

    @property
    def m11(self):
        """Matrix fourth row (4 components)"""
        return _mod.mem.getFloat32(self._address + 56, True)

    @m11.setter
    def m11(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 56, value, True)

    @property
    def m15(self):
        """Matrix fourth row (4 components)"""
        return _mod.mem.getFloat32(self._address + 60, True)

    @m15.setter
    def m15(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 60, value, True)

    def __str__(self):
        return f"Matrix(address={self._address}, {self.m0}, {self.m4}, {self.m8}, {self.m12}, {self.m1}, {self.m5}, {self.m9}, {self.m13}, {self.m2}, {self.m6}, {self.m10}, {self.m14}, {self.m3}, {self.m7}, {self.m11}, {self.m15})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Color:
    """Color, 4 components, R8G8B8A8 (32bit)"""

    _size: int = 4

    def __init__(self, r: int = 0, g: int = 0, b: int = 0, a: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(4)
            self._to_free = True
            _mod.mem.setUint8(self._address + 0, r)
            _mod.mem.setUint8(self._address + 1, g)
            _mod.mem.setUint8(self._address + 2, b)
            _mod.mem.setUint8(self._address + 3, a)

    @property
    def r(self):
        """Color red value"""
        return _mod.mem.getUint8(self._address + 0, True)

    @r.setter
    def r(self, value):
        if not self._frozen:
            _mod.mem.setUint8(self._address + 0, value, True)

    @property
    def g(self):
        """Color green value"""
        return _mod.mem.getUint8(self._address + 1, True)

    @g.setter
    def g(self, value):
        if not self._frozen:
            _mod.mem.setUint8(self._address + 1, value, True)

    @property
    def b(self):
        """Color blue value"""
        return _mod.mem.getUint8(self._address + 2, True)

    @b.setter
    def b(self, value):
        if not self._frozen:
            _mod.mem.setUint8(self._address + 2, value, True)

    @property
    def a(self):
        """Color alpha value"""
        return _mod.mem.getUint8(self._address + 3, True)

    @a.setter
    def a(self, value):
        if not self._frozen:
            _mod.mem.setUint8(self._address + 3, value, True)

    def __str__(self):
        return f"Color(address={self._address}, {self.r}, {self.g}, {self.b}, {self.a})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Rectangle:
    """Rectangle, 4 components"""

    _size: int = 16

    def __init__(self, x: float = 0.0, y: float = 0.0, width: float = 0.0, height: float = 0.0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(16)
            self._to_free = True
            _mod.mem.setFloat32(self._address + 0, x)
            _mod.mem.setFloat32(self._address + 4, y)
            _mod.mem.setFloat32(self._address + 8, width)
            _mod.mem.setFloat32(self._address + 12, height)

    @property
    def x(self):
        """Rectangle top-left corner position x"""
        return _mod.mem.getFloat32(self._address + 0, True)

    @x.setter
    def x(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 0, value, True)

    @property
    def y(self):
        """Rectangle top-left corner position y"""
        return _mod.mem.getFloat32(self._address + 4, True)

    @y.setter
    def y(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 4, value, True)

    @property
    def width(self):
        """Rectangle width"""
        return _mod.mem.getFloat32(self._address + 8, True)

    @width.setter
    def width(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 8, value, True)

    @property
    def height(self):
        """Rectangle height"""
        return _mod.mem.getFloat32(self._address + 12, True)

    @height.setter
    def height(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 12, value, True)

    def __str__(self):
        return f"Rectangle(address={self._address}, {self.x}, {self.y}, {self.width}, {self.height})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Image:
    """Image, pixel data stored in CPU memory (RAM)"""

    _size: int = 20

    def __init__(self, data: int = 0, width: int = 0, height: int = 0, mipmaps: int = 0, format: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(20)
            self._to_free = True
            _mod.mem.setUint32(self._address + 0, data)
            _mod.mem.setInt32(self._address + 4, width)
            _mod.mem.setInt32(self._address + 8, height)
            _mod.mem.setInt32(self._address + 12, mipmaps)
            _mod.mem.setInt32(self._address + 16, format)

    @property
    def data(self):
        """Image raw data"""
        return _mod.mem.getUint32(self._address + 0, True)

    @data.setter
    def data(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 0, value, True)

    @property
    def width(self):
        """Image base width"""
        return _mod.mem.getInt32(self._address + 4, True)

    @width.setter
    def width(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 4, value, True)

    @property
    def height(self):
        """Image base height"""
        return _mod.mem.getInt32(self._address + 8, True)

    @height.setter
    def height(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 8, value, True)

    @property
    def mipmaps(self):
        """Mipmap levels, 1 by default"""
        return _mod.mem.getInt32(self._address + 12, True)

    @mipmaps.setter
    def mipmaps(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 12, value, True)

    @property
    def format(self):
        """Data format (PixelFormat type)"""
        return _mod.mem.getInt32(self._address + 16, True)

    @format.setter
    def format(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 16, value, True)

    def __str__(self):
        return f"Image(address={self._address}, {self.data}, {self.width}, {self.height}, {self.mipmaps}, {self.format})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Texture:
    """Texture, tex data stored in GPU memory (VRAM)"""

    _size: int = 20

    def __init__(self, id: int = 0, width: int = 0, height: int = 0, mipmaps: int = 0, format: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(20)
            self._to_free = True
            _mod.mem.setUint32(self._address + 0, id)
            _mod.mem.setInt32(self._address + 4, width)
            _mod.mem.setInt32(self._address + 8, height)
            _mod.mem.setInt32(self._address + 12, mipmaps)
            _mod.mem.setInt32(self._address + 16, format)

    @property
    def id(self):
        """OpenGL texture id"""
        return _mod.mem.getUint32(self._address + 0, True)

    @id.setter
    def id(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 0, value, True)

    @property
    def width(self):
        """Texture base width"""
        return _mod.mem.getInt32(self._address + 4, True)

    @width.setter
    def width(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 4, value, True)

    @property
    def height(self):
        """Texture base height"""
        return _mod.mem.getInt32(self._address + 8, True)

    @height.setter
    def height(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 8, value, True)

    @property
    def mipmaps(self):
        """Mipmap levels, 1 by default"""
        return _mod.mem.getInt32(self._address + 12, True)

    @mipmaps.setter
    def mipmaps(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 12, value, True)

    @property
    def format(self):
        """Data format (PixelFormat type)"""
        return _mod.mem.getInt32(self._address + 16, True)

    @format.setter
    def format(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 16, value, True)

    def __str__(self):
        return f"Texture(address={self._address}, {self.id}, {self.width}, {self.height}, {self.mipmaps}, {self.format})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

Texture2D = Texture

TextureCubemap = Texture

class RenderTexture:
    """RenderTexture, fbo for texture rendering"""

    _size: int = 44

    def __init__(self, id: int = 0, texture: Texture = None, depth: Texture = None, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(44)
            self._to_free = True
            _mod.mem.setUint32(self._address + 0, id)
            if texture is not None:
                struct_clone(texture, self._address + 4)
            if depth is not None:
                struct_clone(depth, self._address + 24)

    @property
    def id(self):
        """OpenGL framebuffer object id"""
        return _mod.mem.getUint32(self._address + 0, True)

    @id.setter
    def id(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 0, value, True)

    @property
    def texture(self):
        """Color buffer attachment texture"""
        return Texture(0, address=self._address + 4)

    @texture.setter
    def texture(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 4)

    @property
    def depth(self):
        """Depth buffer attachment texture"""
        return Texture(0, address=self._address + 24)

    @depth.setter
    def depth(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 24)

    def __str__(self):
        return f"RenderTexture(address={self._address}, {self.id}, {self.texture}, {self.depth})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

RenderTexture2D = RenderTexture

class NPatchInfo:
    """NPatchInfo, n-patch layout info"""

    _size: int = 36

    def __init__(self, source: Rectangle = None, left: int = 0, top: int = 0, right: int = 0, bottom: int = 0, layout: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(36)
            self._to_free = True
            if source is not None:
                struct_clone(source, self._address + 0)
            _mod.mem.setInt32(self._address + 16, left)
            _mod.mem.setInt32(self._address + 20, top)
            _mod.mem.setInt32(self._address + 24, right)
            _mod.mem.setInt32(self._address + 28, bottom)
            _mod.mem.setInt32(self._address + 32, layout)

    @property
    def source(self):
        """Texture source rectangle"""
        return Rectangle(0, address=self._address + 0)

    @source.setter
    def source(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 0)

    @property
    def left(self):
        """Left border offset"""
        return _mod.mem.getInt32(self._address + 16, True)

    @left.setter
    def left(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 16, value, True)

    @property
    def top(self):
        """Top border offset"""
        return _mod.mem.getInt32(self._address + 20, True)

    @top.setter
    def top(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 20, value, True)

    @property
    def right(self):
        """Right border offset"""
        return _mod.mem.getInt32(self._address + 24, True)

    @right.setter
    def right(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 24, value, True)

    @property
    def bottom(self):
        """Bottom border offset"""
        return _mod.mem.getInt32(self._address + 28, True)

    @bottom.setter
    def bottom(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 28, value, True)

    @property
    def layout(self):
        """Layout of the n-patch: 3x3, 1x3 or 3x1"""
        return _mod.mem.getInt32(self._address + 32, True)

    @layout.setter
    def layout(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 32, value, True)

    def __str__(self):
        return f"NPatchInfo(address={self._address}, {self.source}, {self.left}, {self.top}, {self.right}, {self.bottom}, {self.layout})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class GlyphInfo:
    """GlyphInfo, font characters glyphs info"""

    _size: int = 36

    def __init__(self, value: int = 0, offsetX: int = 0, offsetY: int = 0, advanceX: int = 0, image: Image = None, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(36)
            self._to_free = True
            _mod.mem.setInt32(self._address + 0, value)
            _mod.mem.setInt32(self._address + 4, offsetX)
            _mod.mem.setInt32(self._address + 8, offsetY)
            _mod.mem.setInt32(self._address + 12, advanceX)
            if image is not None:
                struct_clone(image, self._address + 16)

    @property
    def value(self):
        """Character value (Unicode)"""
        return _mod.mem.getInt32(self._address + 0, True)

    @value.setter
    def value(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 0, value, True)

    @property
    def offsetX(self):
        """Character offset X when drawing"""
        return _mod.mem.getInt32(self._address + 4, True)

    @offsetX.setter
    def offsetX(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 4, value, True)

    @property
    def offsetY(self):
        """Character offset Y when drawing"""
        return _mod.mem.getInt32(self._address + 8, True)

    @offsetY.setter
    def offsetY(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 8, value, True)

    @property
    def advanceX(self):
        """Character advance position X"""
        return _mod.mem.getInt32(self._address + 12, True)

    @advanceX.setter
    def advanceX(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 12, value, True)

    @property
    def image(self):
        """Character image data"""
        return Image(0, address=self._address + 16)

    @image.setter
    def image(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 16)

    def __str__(self):
        return f"GlyphInfo(address={self._address}, {self.value}, {self.offsetX}, {self.offsetY}, {self.advanceX}, {self.image})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Font:
    """Font, font texture and GlyphInfo array data"""

    _size: int = 40

    def __init__(self, baseSize: int = 0, glyphCount: int = 0, glyphPadding: int = 0, texture: Texture2D = None, recs: int = 0, glyphs: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(40)
            self._to_free = True
            _mod.mem.setInt32(self._address + 0, baseSize)
            _mod.mem.setInt32(self._address + 4, glyphCount)
            _mod.mem.setInt32(self._address + 8, glyphPadding)
            if texture is not None:
                struct_clone(texture, self._address + 12)
            _mod.mem.setUint32(self._address + 32, recs)
            _mod.mem.setUint32(self._address + 36, glyphs)

    @property
    def baseSize(self):
        """Base size (default chars height)"""
        return _mod.mem.getInt32(self._address + 0, True)

    @baseSize.setter
    def baseSize(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 0, value, True)

    @property
    def glyphCount(self):
        """Number of glyph characters"""
        return _mod.mem.getInt32(self._address + 4, True)

    @glyphCount.setter
    def glyphCount(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 4, value, True)

    @property
    def glyphPadding(self):
        """Padding around the glyph characters"""
        return _mod.mem.getInt32(self._address + 8, True)

    @glyphPadding.setter
    def glyphPadding(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 8, value, True)

    @property
    def texture(self):
        """Texture atlas containing the glyphs"""
        return Texture2D(0, address=self._address + 12)

    @texture.setter
    def texture(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 12)

    @property
    def recs(self):
        """Rectangles in texture for the glyphs"""
        return _mod.mem.getUint32(self._address + 32, True)

    @recs.setter
    def recs(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 32, value, True)

    @property
    def glyphs(self):
        """Glyphs info data"""
        return _mod.mem.getUint32(self._address + 36, True)

    @glyphs.setter
    def glyphs(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 36, value, True)

    def __str__(self):
        return f"Font(address={self._address}, {self.baseSize}, {self.glyphCount}, {self.glyphPadding}, {self.texture}, {self.recs}, {self.glyphs})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Camera3D:
    """Camera, defines position/orientation in 3d space"""

    _size: int = 44

    def __init__(self, position: Vector3 = None, target: Vector3 = None, up: Vector3 = None, fovy: float = 0.0, projection: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(44)
            self._to_free = True
            if position is not None:
                struct_clone(position, self._address + 0)
            if target is not None:
                struct_clone(target, self._address + 12)
            if up is not None:
                struct_clone(up, self._address + 24)
            _mod.mem.setFloat32(self._address + 36, fovy)
            _mod.mem.setInt32(self._address + 40, projection)

    @property
    def position(self):
        """Camera position"""
        return Vector3(0, address=self._address + 0)

    @position.setter
    def position(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 0)

    @property
    def target(self):
        """Camera target it looks-at"""
        return Vector3(0, address=self._address + 12)

    @target.setter
    def target(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 12)

    @property
    def up(self):
        """Camera up vector (rotation over its axis)"""
        return Vector3(0, address=self._address + 24)

    @up.setter
    def up(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 24)

    @property
    def fovy(self):
        """Camera field-of-view aperture in Y (degrees) in perspective, used as near plane width in orthographic"""
        return _mod.mem.getFloat32(self._address + 36, True)

    @fovy.setter
    def fovy(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 36, value, True)

    @property
    def projection(self):
        """Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC"""
        return _mod.mem.getInt32(self._address + 40, True)

    @projection.setter
    def projection(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 40, value, True)

    def __str__(self):
        return f"Camera3D(address={self._address}, {self.position}, {self.target}, {self.up}, {self.fovy}, {self.projection})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

Camera = Camera3D

class Camera2D:
    """Camera2D, defines position/orientation in 2d space"""

    _size: int = 24

    def __init__(self, offset: Vector2 = None, target: Vector2 = None, rotation: float = 0.0, zoom: float = 0.0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(24)
            self._to_free = True
            if offset is not None:
                struct_clone(offset, self._address + 0)
            if target is not None:
                struct_clone(target, self._address + 8)
            _mod.mem.setFloat32(self._address + 16, rotation)
            _mod.mem.setFloat32(self._address + 20, zoom)

    @property
    def offset(self):
        """Camera offset (displacement from target)"""
        return Vector2(0, address=self._address + 0)

    @offset.setter
    def offset(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 0)

    @property
    def target(self):
        """Camera target (rotation and zoom origin)"""
        return Vector2(0, address=self._address + 8)

    @target.setter
    def target(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 8)

    @property
    def rotation(self):
        """Camera rotation in degrees"""
        return _mod.mem.getFloat32(self._address + 16, True)

    @rotation.setter
    def rotation(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 16, value, True)

    @property
    def zoom(self):
        """Camera zoom (scaling), should be 1.0f by default"""
        return _mod.mem.getFloat32(self._address + 20, True)

    @zoom.setter
    def zoom(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 20, value, True)

    def __str__(self):
        return f"Camera2D(address={self._address}, {self.offset}, {self.target}, {self.rotation}, {self.zoom})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Mesh:
    """Mesh, vertex data and vao/vbo"""

    _size: int = 60

    def __init__(self, vertexCount: int = 0, triangleCount: int = 0, vertices: int = 0, texcoords: int = 0, texcoords2: int = 0, normals: int = 0, tangents: int = 0, colors: int = 0, indices: int = 0, animVertices: int = 0, animNormals: int = 0, boneIds: int = 0, boneWeights: int = 0, vaoId: int = 0, vboId: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(60)
            self._to_free = True
            _mod.mem.setInt32(self._address + 0, vertexCount)
            _mod.mem.setInt32(self._address + 4, triangleCount)
            _mod.mem.setUint32(self._address + 8, vertices)
            _mod.mem.setUint32(self._address + 12, texcoords)
            _mod.mem.setUint32(self._address + 16, texcoords2)
            _mod.mem.setUint32(self._address + 20, normals)
            _mod.mem.setUint32(self._address + 24, tangents)
            _mod.mem.setUint32(self._address + 28, colors)
            _mod.mem.setUint32(self._address + 32, indices)
            _mod.mem.setUint32(self._address + 36, animVertices)
            _mod.mem.setUint32(self._address + 40, animNormals)
            _mod.mem.setUint32(self._address + 44, boneIds)
            _mod.mem.setUint32(self._address + 48, boneWeights)
            _mod.mem.setUint32(self._address + 52, vaoId)
            _mod.mem.setUint32(self._address + 56, vboId)

    @property
    def vertexCount(self):
        """Number of vertices stored in arrays"""
        return _mod.mem.getInt32(self._address + 0, True)

    @vertexCount.setter
    def vertexCount(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 0, value, True)

    @property
    def triangleCount(self):
        """Number of triangles stored (indexed or not)"""
        return _mod.mem.getInt32(self._address + 4, True)

    @triangleCount.setter
    def triangleCount(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 4, value, True)

    @property
    def vertices(self):
        """Vertex position (XYZ - 3 components per vertex) (shader-location = 0)"""
        return _mod.mem.getUint32(self._address + 8, True)

    @vertices.setter
    def vertices(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 8, value, True)

    @property
    def texcoords(self):
        """Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)"""
        return _mod.mem.getUint32(self._address + 12, True)

    @texcoords.setter
    def texcoords(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 12, value, True)

    @property
    def texcoords2(self):
        """Vertex texture second coordinates (UV - 2 components per vertex) (shader-location = 5)"""
        return _mod.mem.getUint32(self._address + 16, True)

    @texcoords2.setter
    def texcoords2(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 16, value, True)

    @property
    def normals(self):
        """Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)"""
        return _mod.mem.getUint32(self._address + 20, True)

    @normals.setter
    def normals(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 20, value, True)

    @property
    def tangents(self):
        """Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)"""
        return _mod.mem.getUint32(self._address + 24, True)

    @tangents.setter
    def tangents(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 24, value, True)

    @property
    def colors(self):
        """Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)"""
        return _mod.mem.getUint32(self._address + 28, True)

    @colors.setter
    def colors(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 28, value, True)

    @property
    def indices(self):
        """Vertex indices (in case vertex data comes indexed)"""
        return _mod.mem.getUint32(self._address + 32, True)

    @indices.setter
    def indices(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 32, value, True)

    @property
    def animVertices(self):
        """Animated vertex positions (after bones transformations)"""
        return _mod.mem.getUint32(self._address + 36, True)

    @animVertices.setter
    def animVertices(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 36, value, True)

    @property
    def animNormals(self):
        """Animated normals (after bones transformations)"""
        return _mod.mem.getUint32(self._address + 40, True)

    @animNormals.setter
    def animNormals(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 40, value, True)

    @property
    def boneIds(self):
        """Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning)"""
        return _mod.mem.getUint32(self._address + 44, True)

    @boneIds.setter
    def boneIds(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 44, value, True)

    @property
    def boneWeights(self):
        """Vertex bone weight, up to 4 bones influence by vertex (skinning)"""
        return _mod.mem.getUint32(self._address + 48, True)

    @boneWeights.setter
    def boneWeights(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 48, value, True)

    @property
    def vaoId(self):
        """OpenGL Vertex Array Object id"""
        return _mod.mem.getUint32(self._address + 52, True)

    @vaoId.setter
    def vaoId(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 52, value, True)

    @property
    def vboId(self):
        """OpenGL Vertex Buffer Objects id (default vertex data)"""
        return _mod.mem.getUint32(self._address + 56, True)

    @vboId.setter
    def vboId(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 56, value, True)

    def __str__(self):
        return f"Mesh(address={self._address}, {self.vertexCount}, {self.triangleCount}, {self.vertices}, {self.texcoords}, {self.texcoords2}, {self.normals}, {self.tangents}, {self.colors}, {self.indices}, {self.animVertices}, {self.animNormals}, {self.boneIds}, {self.boneWeights}, {self.vaoId}, {self.vboId})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Shader:
    """Shader"""

    _size: int = 8

    def __init__(self, id: int = 0, locs: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(8)
            self._to_free = True
            _mod.mem.setUint32(self._address + 0, id)
            _mod.mem.setUint32(self._address + 4, locs)

    @property
    def id(self):
        """Shader program id"""
        return _mod.mem.getUint32(self._address + 0, True)

    @id.setter
    def id(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 0, value, True)

    @property
    def locs(self):
        """Shader locations array (RL_MAX_SHADER_LOCATIONS)"""
        return _mod.mem.getUint32(self._address + 4, True)

    @locs.setter
    def locs(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 4, value, True)

    def __str__(self):
        return f"Shader(address={self._address}, {self.id}, {self.locs})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class MaterialMap:
    """MaterialMap"""

    _size: int = 28

    def __init__(self, texture: Texture2D = None, color: Color = None, value: float = 0.0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(28)
            self._to_free = True
            if texture is not None:
                struct_clone(texture, self._address + 0)
            if color is not None:
                struct_clone(color, self._address + 20)
            _mod.mem.setFloat32(self._address + 24, value)

    @property
    def texture(self):
        """Material map texture"""
        return Texture2D(0, address=self._address + 0)

    @texture.setter
    def texture(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 0)

    @property
    def color(self):
        """Material map color"""
        return Color(0, address=self._address + 20)

    @color.setter
    def color(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 20)

    @property
    def value(self):
        """Material map value"""
        return _mod.mem.getFloat32(self._address + 24, True)

    @value.setter
    def value(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 24, value, True)

    def __str__(self):
        return f"MaterialMap(address={self._address}, {self.texture}, {self.color}, {self.value})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Material:
    """Material, includes shader and maps"""

    _size: int = 28

    def __init__(self, shader: Shader = None, maps: int = 0, params: FloatArray = None, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(28)
            self._to_free = True
            if shader is not None:
                struct_clone(shader, self._address + 0)
            _mod.mem.setUint32(self._address + 8, maps)
            if params is not None:
                struct_clone(params, self._address + 12)

    @property
    def shader(self):
        """Material shader"""
        return Shader(0, address=self._address + 0)

    @shader.setter
    def shader(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 0)

    @property
    def maps(self):
        """Material maps array (MAX_MATERIAL_MAPS)"""
        return _mod.mem.getUint32(self._address + 8, True)

    @maps.setter
    def maps(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 8, value, True)

    @property
    def params(self):
        """Material generic parameters (if required)"""
        return FloatArray(4, address=self._address + 12)

    @params.setter
    def params(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 12)

    def __str__(self):
        return f"Material(address={self._address}, {self.shader}, {self.maps}, {self.params})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Transform:
    """Transform, vertex transformation data"""

    _size: int = 40

    def __init__(self, translation: Vector3 = None, rotation: Quaternion = None, scale: Vector3 = None, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(40)
            self._to_free = True
            if translation is not None:
                struct_clone(translation, self._address + 0)
            if rotation is not None:
                struct_clone(rotation, self._address + 12)
            if scale is not None:
                struct_clone(scale, self._address + 28)

    @property
    def translation(self):
        """Translation"""
        return Vector3(0, address=self._address + 0)

    @translation.setter
    def translation(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 0)

    @property
    def rotation(self):
        """Rotation"""
        return Quaternion(0, address=self._address + 12)

    @rotation.setter
    def rotation(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 12)

    @property
    def scale(self):
        """Scale"""
        return Vector3(0, address=self._address + 28)

    @scale.setter
    def scale(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 28)

    def __str__(self):
        return f"Transform(address={self._address}, {self.translation}, {self.rotation}, {self.scale})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class BoneInfo:
    """Bone, skeletal animation bone"""

    _size: int = 36

    def __init__(self, name: CharArray = None, parent: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(36)
            self._to_free = True
            if name is not None:
                struct_clone(name, self._address + 0)
            _mod.mem.setInt32(self._address + 32, parent)

    @property
    def name(self):
        """Bone name"""
        return CharArray(32, address=self._address + 0)

    @name.setter
    def name(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 0)

    @property
    def parent(self):
        """Bone parent"""
        return _mod.mem.getInt32(self._address + 32, True)

    @parent.setter
    def parent(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 32, value, True)

    def __str__(self):
        return f"BoneInfo(address={self._address}, {self.name}, {self.parent})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Model:
    """Model, meshes, materials and animation data"""

    _size: int = 96

    def __init__(self, transform: Matrix = None, meshCount: int = 0, materialCount: int = 0, meshes: int = 0, materials: int = 0, meshMaterial: int = 0, boneCount: int = 0, bones: int = 0, bindPose: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(96)
            self._to_free = True
            if transform is not None:
                struct_clone(transform, self._address + 0)
            _mod.mem.setInt32(self._address + 64, meshCount)
            _mod.mem.setInt32(self._address + 68, materialCount)
            _mod.mem.setUint32(self._address + 72, meshes)
            _mod.mem.setUint32(self._address + 76, materials)
            _mod.mem.setUint32(self._address + 80, meshMaterial)
            _mod.mem.setInt32(self._address + 84, boneCount)
            _mod.mem.setUint32(self._address + 88, bones)
            _mod.mem.setUint32(self._address + 92, bindPose)

    @property
    def transform(self):
        """Local transform matrix"""
        return Matrix(0, address=self._address + 0)

    @transform.setter
    def transform(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 0)

    @property
    def meshCount(self):
        """Number of meshes"""
        return _mod.mem.getInt32(self._address + 64, True)

    @meshCount.setter
    def meshCount(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 64, value, True)

    @property
    def materialCount(self):
        """Number of materials"""
        return _mod.mem.getInt32(self._address + 68, True)

    @materialCount.setter
    def materialCount(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 68, value, True)

    @property
    def meshes(self):
        """Meshes array"""
        return _mod.mem.getUint32(self._address + 72, True)

    @meshes.setter
    def meshes(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 72, value, True)

    @property
    def materials(self):
        """Materials array"""
        return _mod.mem.getUint32(self._address + 76, True)

    @materials.setter
    def materials(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 76, value, True)

    @property
    def meshMaterial(self):
        """Mesh material number"""
        return _mod.mem.getUint32(self._address + 80, True)

    @meshMaterial.setter
    def meshMaterial(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 80, value, True)

    @property
    def boneCount(self):
        """Number of bones"""
        return _mod.mem.getInt32(self._address + 84, True)

    @boneCount.setter
    def boneCount(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 84, value, True)

    @property
    def bones(self):
        """Bones information (skeleton)"""
        return _mod.mem.getUint32(self._address + 88, True)

    @bones.setter
    def bones(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 88, value, True)

    @property
    def bindPose(self):
        """Bones base transformation (pose)"""
        return _mod.mem.getUint32(self._address + 92, True)

    @bindPose.setter
    def bindPose(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 92, value, True)

    def __str__(self):
        return f"Model(address={self._address}, {self.transform}, {self.meshCount}, {self.materialCount}, {self.meshes}, {self.materials}, {self.meshMaterial}, {self.boneCount}, {self.bones}, {self.bindPose})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class ModelAnimation:
    """ModelAnimation"""

    _size: int = 48

    def __init__(self, boneCount: int = 0, frameCount: int = 0, bones: int = 0, framePoses: int = 0, name: CharArray = None, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(48)
            self._to_free = True
            _mod.mem.setInt32(self._address + 0, boneCount)
            _mod.mem.setInt32(self._address + 4, frameCount)
            _mod.mem.setUint32(self._address + 8, bones)
            _mod.mem.setUint32(self._address + 12, framePoses)
            if name is not None:
                struct_clone(name, self._address + 16)

    @property
    def boneCount(self):
        """Number of bones"""
        return _mod.mem.getInt32(self._address + 0, True)

    @boneCount.setter
    def boneCount(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 0, value, True)

    @property
    def frameCount(self):
        """Number of animation frames"""
        return _mod.mem.getInt32(self._address + 4, True)

    @frameCount.setter
    def frameCount(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 4, value, True)

    @property
    def bones(self):
        """Bones information (skeleton)"""
        return _mod.mem.getUint32(self._address + 8, True)

    @bones.setter
    def bones(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 8, value, True)

    @property
    def framePoses(self):
        """Poses array by frame"""
        return _mod.mem.getUint32(self._address + 12, True)

    @framePoses.setter
    def framePoses(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 12, value, True)

    @property
    def name(self):
        """Animation name"""
        return CharArray(32, address=self._address + 16)

    @name.setter
    def name(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 16)

    def __str__(self):
        return f"ModelAnimation(address={self._address}, {self.boneCount}, {self.frameCount}, {self.bones}, {self.framePoses}, {self.name})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Ray:
    """Ray, ray for raycasting"""

    _size: int = 24

    def __init__(self, position: Vector3 = None, direction: Vector3 = None, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(24)
            self._to_free = True
            if position is not None:
                struct_clone(position, self._address + 0)
            if direction is not None:
                struct_clone(direction, self._address + 12)

    @property
    def position(self):
        """Ray position (origin)"""
        return Vector3(0, address=self._address + 0)

    @position.setter
    def position(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 0)

    @property
    def direction(self):
        """Ray direction"""
        return Vector3(0, address=self._address + 12)

    @direction.setter
    def direction(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 12)

    def __str__(self):
        return f"Ray(address={self._address}, {self.position}, {self.direction})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class RayCollision:
    """RayCollision, ray hit information"""

    _size: int = 29

    def __init__(self, hit: int = 0, distance: float = 0.0, point: Vector3 = None, normal: Vector3 = None, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(29)
            self._to_free = True
            _mod.mem.setInt8(self._address + 0, hit)
            _mod.mem.setFloat32(self._address + 1, distance)
            if point is not None:
                struct_clone(point, self._address + 5)
            if normal is not None:
                struct_clone(normal, self._address + 17)

    @property
    def hit(self):
        """Did the ray hit something?"""
        return _mod.mem.getInt8(self._address + 0, True)

    @hit.setter
    def hit(self, value):
        if not self._frozen:
            _mod.mem.setInt8(self._address + 0, value, True)

    @property
    def distance(self):
        """Distance to the nearest hit"""
        return _mod.mem.getFloat32(self._address + 1, True)

    @distance.setter
    def distance(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 1, value, True)

    @property
    def point(self):
        """Point of the nearest hit"""
        return Vector3(0, address=self._address + 5)

    @point.setter
    def point(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 5)

    @property
    def normal(self):
        """Surface normal of hit"""
        return Vector3(0, address=self._address + 17)

    @normal.setter
    def normal(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 17)

    def __str__(self):
        return f"RayCollision(address={self._address}, {self.hit}, {self.distance}, {self.point}, {self.normal})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class BoundingBox:
    """BoundingBox"""

    _size: int = 24

    def __init__(self, min: Vector3 = None, max: Vector3 = None, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(24)
            self._to_free = True
            if min is not None:
                struct_clone(min, self._address + 0)
            if max is not None:
                struct_clone(max, self._address + 12)

    @property
    def min(self):
        """Minimum vertex box-corner"""
        return Vector3(0, address=self._address + 0)

    @min.setter
    def min(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 0)

    @property
    def max(self):
        """Maximum vertex box-corner"""
        return Vector3(0, address=self._address + 12)

    @max.setter
    def max(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 12)

    def __str__(self):
        return f"BoundingBox(address={self._address}, {self.min}, {self.max})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Wave:
    """Wave, audio wave data"""

    _size: int = 20

    def __init__(self, frameCount: int = 0, sampleRate: int = 0, sampleSize: int = 0, channels: int = 0, data: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(20)
            self._to_free = True
            _mod.mem.setUint32(self._address + 0, frameCount)
            _mod.mem.setUint32(self._address + 4, sampleRate)
            _mod.mem.setUint32(self._address + 8, sampleSize)
            _mod.mem.setUint32(self._address + 12, channels)
            _mod.mem.setUint32(self._address + 16, data)

    @property
    def frameCount(self):
        """Total number of frames (considering channels)"""
        return _mod.mem.getUint32(self._address + 0, True)

    @frameCount.setter
    def frameCount(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 0, value, True)

    @property
    def sampleRate(self):
        """Frequency (samples per second)"""
        return _mod.mem.getUint32(self._address + 4, True)

    @sampleRate.setter
    def sampleRate(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 4, value, True)

    @property
    def sampleSize(self):
        """Bit depth (bits per sample): 8, 16, 32 (24 not supported)"""
        return _mod.mem.getUint32(self._address + 8, True)

    @sampleSize.setter
    def sampleSize(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 8, value, True)

    @property
    def channels(self):
        """Number of channels (1-mono, 2-stereo, ...)"""
        return _mod.mem.getUint32(self._address + 12, True)

    @channels.setter
    def channels(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 12, value, True)

    @property
    def data(self):
        """Buffer data pointer"""
        return _mod.mem.getUint32(self._address + 16, True)

    @data.setter
    def data(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 16, value, True)

    def __str__(self):
        return f"Wave(address={self._address}, {self.frameCount}, {self.sampleRate}, {self.sampleSize}, {self.channels}, {self.data})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class AudioStream:
    """AudioStream, custom audio stream"""

    _size: int = 20

    def __init__(self, buffer: int = 0, processor: int = 0, sampleRate: int = 0, sampleSize: int = 0, channels: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(20)
            self._to_free = True
            _mod.mem.setUint32(self._address + 0, buffer)
            _mod.mem.setUint32(self._address + 4, processor)
            _mod.mem.setUint32(self._address + 8, sampleRate)
            _mod.mem.setUint32(self._address + 12, sampleSize)
            _mod.mem.setUint32(self._address + 16, channels)

    @property
    def buffer(self):
        """Pointer to internal data used by the audio system"""
        return _mod.mem.getUint32(self._address + 0, True)

    @buffer.setter
    def buffer(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 0, value, True)

    @property
    def processor(self):
        """Pointer to internal data processor, useful for audio effects"""
        return _mod.mem.getUint32(self._address + 4, True)

    @processor.setter
    def processor(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 4, value, True)

    @property
    def sampleRate(self):
        """Frequency (samples per second)"""
        return _mod.mem.getUint32(self._address + 8, True)

    @sampleRate.setter
    def sampleRate(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 8, value, True)

    @property
    def sampleSize(self):
        """Bit depth (bits per sample): 8, 16, 32 (24 not supported)"""
        return _mod.mem.getUint32(self._address + 12, True)

    @sampleSize.setter
    def sampleSize(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 12, value, True)

    @property
    def channels(self):
        """Number of channels (1-mono, 2-stereo, ...)"""
        return _mod.mem.getUint32(self._address + 16, True)

    @channels.setter
    def channels(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 16, value, True)

    def __str__(self):
        return f"AudioStream(address={self._address}, {self.buffer}, {self.processor}, {self.sampleRate}, {self.sampleSize}, {self.channels})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Sound:
    """Sound"""

    _size: int = 24

    def __init__(self, stream: AudioStream = None, frameCount: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(24)
            self._to_free = True
            if stream is not None:
                struct_clone(stream, self._address + 0)
            _mod.mem.setUint32(self._address + 20, frameCount)

    @property
    def stream(self):
        """Audio stream"""
        return AudioStream(0, address=self._address + 0)

    @stream.setter
    def stream(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 0)

    @property
    def frameCount(self):
        """Total number of frames (considering channels)"""
        return _mod.mem.getUint32(self._address + 20, True)

    @frameCount.setter
    def frameCount(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 20, value, True)

    def __str__(self):
        return f"Sound(address={self._address}, {self.stream}, {self.frameCount})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class Music:
    """Music, audio stream, anything longer than ~10 seconds should be streamed"""

    _size: int = 33

    def __init__(self, stream: AudioStream = None, frameCount: int = 0, looping: int = 0, ctxType: int = 0, ctxData: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(33)
            self._to_free = True
            if stream is not None:
                struct_clone(stream, self._address + 0)
            _mod.mem.setUint32(self._address + 20, frameCount)
            _mod.mem.setInt8(self._address + 24, looping)
            _mod.mem.setInt32(self._address + 25, ctxType)
            _mod.mem.setUint32(self._address + 29, ctxData)

    @property
    def stream(self):
        """Audio stream"""
        return AudioStream(0, address=self._address + 0)

    @stream.setter
    def stream(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 0)

    @property
    def frameCount(self):
        """Total number of frames (considering channels)"""
        return _mod.mem.getUint32(self._address + 20, True)

    @frameCount.setter
    def frameCount(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 20, value, True)

    @property
    def looping(self):
        """Music looping enable"""
        return _mod.mem.getInt8(self._address + 24, True)

    @looping.setter
    def looping(self, value):
        if not self._frozen:
            _mod.mem.setInt8(self._address + 24, value, True)

    @property
    def ctxType(self):
        """Type of music context (audio filetype)"""
        return _mod.mem.getInt32(self._address + 25, True)

    @ctxType.setter
    def ctxType(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 25, value, True)

    @property
    def ctxData(self):
        """Audio context data, depends on type"""
        return _mod.mem.getUint32(self._address + 29, True)

    @ctxData.setter
    def ctxData(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 29, value, True)

    def __str__(self):
        return f"Music(address={self._address}, {self.stream}, {self.frameCount}, {self.looping}, {self.ctxType}, {self.ctxData})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class VrDeviceInfo:
    """VrDeviceInfo, Head-Mounted-Display device parameters"""

    _size: int = 64

    def __init__(self, hResolution: int = 0, vResolution: int = 0, hScreenSize: float = 0.0, vScreenSize: float = 0.0, vScreenCenter: float = 0.0, eyeToScreenDistance: float = 0.0, lensSeparationDistance: float = 0.0, interpupillaryDistance: float = 0.0, lensDistortionValues: FloatArray = None, chromaAbCorrection: FloatArray = None, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(64)
            self._to_free = True
            _mod.mem.setInt32(self._address + 0, hResolution)
            _mod.mem.setInt32(self._address + 4, vResolution)
            _mod.mem.setFloat32(self._address + 8, hScreenSize)
            _mod.mem.setFloat32(self._address + 12, vScreenSize)
            _mod.mem.setFloat32(self._address + 16, vScreenCenter)
            _mod.mem.setFloat32(self._address + 20, eyeToScreenDistance)
            _mod.mem.setFloat32(self._address + 24, lensSeparationDistance)
            _mod.mem.setFloat32(self._address + 28, interpupillaryDistance)
            if lensDistortionValues is not None:
                struct_clone(lensDistortionValues, self._address + 32)
            if chromaAbCorrection is not None:
                struct_clone(chromaAbCorrection, self._address + 48)

    @property
    def hResolution(self):
        """Horizontal resolution in pixels"""
        return _mod.mem.getInt32(self._address + 0, True)

    @hResolution.setter
    def hResolution(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 0, value, True)

    @property
    def vResolution(self):
        """Vertical resolution in pixels"""
        return _mod.mem.getInt32(self._address + 4, True)

    @vResolution.setter
    def vResolution(self, value):
        if not self._frozen:
            _mod.mem.setInt32(self._address + 4, value, True)

    @property
    def hScreenSize(self):
        """Horizontal size in meters"""
        return _mod.mem.getFloat32(self._address + 8, True)

    @hScreenSize.setter
    def hScreenSize(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 8, value, True)

    @property
    def vScreenSize(self):
        """Vertical size in meters"""
        return _mod.mem.getFloat32(self._address + 12, True)

    @vScreenSize.setter
    def vScreenSize(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 12, value, True)

    @property
    def vScreenCenter(self):
        """Screen center in meters"""
        return _mod.mem.getFloat32(self._address + 16, True)

    @vScreenCenter.setter
    def vScreenCenter(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 16, value, True)

    @property
    def eyeToScreenDistance(self):
        """Distance between eye and display in meters"""
        return _mod.mem.getFloat32(self._address + 20, True)

    @eyeToScreenDistance.setter
    def eyeToScreenDistance(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 20, value, True)

    @property
    def lensSeparationDistance(self):
        """Lens separation distance in meters"""
        return _mod.mem.getFloat32(self._address + 24, True)

    @lensSeparationDistance.setter
    def lensSeparationDistance(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 24, value, True)

    @property
    def interpupillaryDistance(self):
        """IPD (distance between pupils) in meters"""
        return _mod.mem.getFloat32(self._address + 28, True)

    @interpupillaryDistance.setter
    def interpupillaryDistance(self, value):
        if not self._frozen:
            _mod.mem.setFloat32(self._address + 28, value, True)

    @property
    def lensDistortionValues(self):
        """Lens distortion constant parameters"""
        return FloatArray(4, address=self._address + 32)

    @lensDistortionValues.setter
    def lensDistortionValues(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 32)

    @property
    def chromaAbCorrection(self):
        """Chromatic aberration correction parameters"""
        return FloatArray(4, address=self._address + 48)

    @chromaAbCorrection.setter
    def chromaAbCorrection(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 48)

    def __str__(self):
        return f"VrDeviceInfo(address={self._address}, {self.hResolution}, {self.vResolution}, {self.hScreenSize}, {self.vScreenSize}, {self.vScreenCenter}, {self.eyeToScreenDistance}, {self.lensSeparationDistance}, {self.interpupillaryDistance}, {self.lensDistortionValues}, {self.chromaAbCorrection})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class VrStereoConfig:
    """VrStereoConfig, VR stereo rendering configuration for simulator"""

    _size: int = 304

    def __init__(self, projection: StructArray = None, viewOffset: StructArray = None, leftLensCenter: FloatArray = None, rightLensCenter: FloatArray = None, leftScreenCenter: FloatArray = None, rightScreenCenter: FloatArray = None, scale: FloatArray = None, scaleIn: FloatArray = None, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(304)
            self._to_free = True
            if projection is not None:
                struct_clone(projection, self._address + 0)
            if viewOffset is not None:
                struct_clone(viewOffset, self._address + 128)
            if leftLensCenter is not None:
                struct_clone(leftLensCenter, self._address + 256)
            if rightLensCenter is not None:
                struct_clone(rightLensCenter, self._address + 264)
            if leftScreenCenter is not None:
                struct_clone(leftScreenCenter, self._address + 272)
            if rightScreenCenter is not None:
                struct_clone(rightScreenCenter, self._address + 280)
            if scale is not None:
                struct_clone(scale, self._address + 288)
            if scaleIn is not None:
                struct_clone(scaleIn, self._address + 296)

    @property
    def projection(self):
        """VR projection matrices (per eye)"""
        return StructArray(Matrix, 2, address=self._address + 0)

    @projection.setter
    def projection(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 0)

    @property
    def viewOffset(self):
        """VR view offset matrices (per eye)"""
        return StructArray(Matrix, 2, address=self._address + 128)

    @viewOffset.setter
    def viewOffset(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 128)

    @property
    def leftLensCenter(self):
        """VR left lens center"""
        return FloatArray(2, address=self._address + 256)

    @leftLensCenter.setter
    def leftLensCenter(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 256)

    @property
    def rightLensCenter(self):
        """VR right lens center"""
        return FloatArray(2, address=self._address + 264)

    @rightLensCenter.setter
    def rightLensCenter(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 264)

    @property
    def leftScreenCenter(self):
        """VR left screen center"""
        return FloatArray(2, address=self._address + 272)

    @leftScreenCenter.setter
    def leftScreenCenter(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 272)

    @property
    def rightScreenCenter(self):
        """VR right screen center"""
        return FloatArray(2, address=self._address + 280)

    @rightScreenCenter.setter
    def rightScreenCenter(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 280)

    @property
    def scale(self):
        """VR distortion scale"""
        return FloatArray(2, address=self._address + 288)

    @scale.setter
    def scale(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 288)

    @property
    def scaleIn(self):
        """VR distortion scale in"""
        return FloatArray(2, address=self._address + 296)

    @scaleIn.setter
    def scaleIn(self, value):
        if not self._frozen:
            struct_clone(value, self._address + 296)

    def __str__(self):
        return f"VrStereoConfig(address={self._address}, {self.projection}, {self.viewOffset}, {self.leftLensCenter}, {self.rightLensCenter}, {self.leftScreenCenter}, {self.rightScreenCenter}, {self.scale}, {self.scaleIn})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class FilePathList:
    """File path list"""

    _size: int = 12

    def __init__(self, capacity: int = 0, count: int = 0, paths: int = 0, address: int = 0, frozen: bool = False):
        self._frozen = frozen
        if address != 0:
            self._address = address
            self._to_free = False
        else:
            self._address = _mod._malloc(12)
            self._to_free = True
            _mod.mem.setUint32(self._address + 0, capacity)
            _mod.mem.setUint32(self._address + 4, count)
            _mod.mem.setUint32(self._address + 8, paths)

    @property
    def capacity(self):
        """Filepaths max entries"""
        return _mod.mem.getUint32(self._address + 0, True)

    @capacity.setter
    def capacity(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 0, value, True)

    @property
    def count(self):
        """Filepaths entries count"""
        return _mod.mem.getUint32(self._address + 4, True)

    @count.setter
    def count(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 4, value, True)

    @property
    def paths(self):
        """Filepaths entries"""
        return _mod.mem.getUint32(self._address + 8, True)

    @paths.setter
    def paths(self, value):
        if not self._frozen:
            _mod.mem.setUint32(self._address + 8, value, True)

    def __str__(self):
        return f"FilePathList(address={self._address}, {self.capacity}, {self.count}, {self.paths})"

    def __del__(self):
        if self._to_free:
            _mod._free(self._address)

class ConfigFlags(enum.IntEnum):
    """System/Window config flags"""
    FLAG_VSYNC_HINT: int = 64  # Set to try enabling V-Sync on GPU
    FLAG_FULLSCREEN_MODE: int = 2  # Set to run program in fullscreen
    FLAG_WINDOW_RESIZABLE: int = 4  # Set to allow resizable window
    FLAG_WINDOW_UNDECORATED: int = 8  # Set to disable window decoration (frame and buttons)
    FLAG_WINDOW_HIDDEN: int = 128  # Set to hide window
    FLAG_WINDOW_MINIMIZED: int = 512  # Set to minimize window (iconify)
    FLAG_WINDOW_MAXIMIZED: int = 1024  # Set to maximize window (expanded to monitor)
    FLAG_WINDOW_UNFOCUSED: int = 2048  # Set to window non focused
    FLAG_WINDOW_TOPMOST: int = 4096  # Set to window always on top
    FLAG_WINDOW_ALWAYS_RUN: int = 256  # Set to allow windows running while minimized
    FLAG_WINDOW_TRANSPARENT: int = 16  # Set to allow transparent framebuffer
    FLAG_WINDOW_HIGHDPI: int = 8192  # Set to support HighDPI
    FLAG_WINDOW_MOUSE_PASSTHROUGH: int = 16384  # Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
    FLAG_MSAA_4X_HINT: int = 32  # Set to try enabling MSAA 4X
    FLAG_INTERLACED_HINT: int = 65536  # Set to try enabling interlaced video format (for V3D)


class TraceLogLevel(enum.IntEnum):
    """Trace log level"""
    LOG_ALL: int = 0  # Display all logs
    LOG_TRACE: int = 1  # Trace logging, intended for internal use only
    LOG_DEBUG: int = 2  # Debug logging, used for internal debugging, it should be disabled on release builds
    LOG_INFO: int = 3  # Info logging, used for program execution info
    LOG_WARNING: int = 4  # Warning logging, used on recoverable failures
    LOG_ERROR: int = 5  # Error logging, used on unrecoverable failures
    LOG_FATAL: int = 6  # Fatal logging, used to abort program: exit(EXIT_FAILURE)
    LOG_NONE: int = 7  # Disable logging


class KeyboardKey(enum.IntEnum):
    """Keyboard keys (US keyboard layout)"""
    KEY_NULL: int = 0  # Key: NULL, used for no key pressed
    KEY_APOSTROPHE: int = 39  # Key: '
    KEY_COMMA: int = 44  # Key: ,
    KEY_MINUS: int = 45  # Key: -
    KEY_PERIOD: int = 46  # Key: .
    KEY_SLASH: int = 47  # Key: /
    KEY_ZERO: int = 48  # Key: 0
    KEY_ONE: int = 49  # Key: 1
    KEY_TWO: int = 50  # Key: 2
    KEY_THREE: int = 51  # Key: 3
    KEY_FOUR: int = 52  # Key: 4
    KEY_FIVE: int = 53  # Key: 5
    KEY_SIX: int = 54  # Key: 6
    KEY_SEVEN: int = 55  # Key: 7
    KEY_EIGHT: int = 56  # Key: 8
    KEY_NINE: int = 57  # Key: 9
    KEY_SEMICOLON: int = 59  # Key: ;
    KEY_EQUAL: int = 61  # Key: =
    KEY_A: int = 65  # Key: A | a
    KEY_B: int = 66  # Key: B | b
    KEY_C: int = 67  # Key: C | c
    KEY_D: int = 68  # Key: D | d
    KEY_E: int = 69  # Key: E | e
    KEY_F: int = 70  # Key: F | f
    KEY_G: int = 71  # Key: G | g
    KEY_H: int = 72  # Key: H | h
    KEY_I: int = 73  # Key: I | i
    KEY_J: int = 74  # Key: J | j
    KEY_K: int = 75  # Key: K | k
    KEY_L: int = 76  # Key: L | l
    KEY_M: int = 77  # Key: M | m
    KEY_N: int = 78  # Key: N | n
    KEY_O: int = 79  # Key: O | o
    KEY_P: int = 80  # Key: P | p
    KEY_Q: int = 81  # Key: Q | q
    KEY_R: int = 82  # Key: R | r
    KEY_S: int = 83  # Key: S | s
    KEY_T: int = 84  # Key: T | t
    KEY_U: int = 85  # Key: U | u
    KEY_V: int = 86  # Key: V | v
    KEY_W: int = 87  # Key: W | w
    KEY_X: int = 88  # Key: X | x
    KEY_Y: int = 89  # Key: Y | y
    KEY_Z: int = 90  # Key: Z | z
    KEY_LEFT_BRACKET: int = 91  # Key: [
    KEY_BACKSLASH: int = 92  # Key: '\'
    KEY_RIGHT_BRACKET: int = 93  # Key: ]
    KEY_GRAVE: int = 96  # Key: `
    KEY_SPACE: int = 32  # Key: Space
    KEY_ESCAPE: int = 256  # Key: Esc
    KEY_ENTER: int = 257  # Key: Enter
    KEY_TAB: int = 258  # Key: Tab
    KEY_BACKSPACE: int = 259  # Key: Backspace
    KEY_INSERT: int = 260  # Key: Ins
    KEY_DELETE: int = 261  # Key: Del
    KEY_RIGHT: int = 262  # Key: Cursor right
    KEY_LEFT: int = 263  # Key: Cursor left
    KEY_DOWN: int = 264  # Key: Cursor down
    KEY_UP: int = 265  # Key: Cursor up
    KEY_PAGE_UP: int = 266  # Key: Page up
    KEY_PAGE_DOWN: int = 267  # Key: Page down
    KEY_HOME: int = 268  # Key: Home
    KEY_END: int = 269  # Key: End
    KEY_CAPS_LOCK: int = 280  # Key: Caps lock
    KEY_SCROLL_LOCK: int = 281  # Key: Scroll down
    KEY_NUM_LOCK: int = 282  # Key: Num lock
    KEY_PRINT_SCREEN: int = 283  # Key: Print screen
    KEY_PAUSE: int = 284  # Key: Pause
    KEY_F1: int = 290  # Key: F1
    KEY_F2: int = 291  # Key: F2
    KEY_F3: int = 292  # Key: F3
    KEY_F4: int = 293  # Key: F4
    KEY_F5: int = 294  # Key: F5
    KEY_F6: int = 295  # Key: F6
    KEY_F7: int = 296  # Key: F7
    KEY_F8: int = 297  # Key: F8
    KEY_F9: int = 298  # Key: F9
    KEY_F10: int = 299  # Key: F10
    KEY_F11: int = 300  # Key: F11
    KEY_F12: int = 301  # Key: F12
    KEY_LEFT_SHIFT: int = 340  # Key: Shift left
    KEY_LEFT_CONTROL: int = 341  # Key: Control left
    KEY_LEFT_ALT: int = 342  # Key: Alt left
    KEY_LEFT_SUPER: int = 343  # Key: Super left
    KEY_RIGHT_SHIFT: int = 344  # Key: Shift right
    KEY_RIGHT_CONTROL: int = 345  # Key: Control right
    KEY_RIGHT_ALT: int = 346  # Key: Alt right
    KEY_RIGHT_SUPER: int = 347  # Key: Super right
    KEY_KB_MENU: int = 348  # Key: KB menu
    KEY_KP_0: int = 320  # Key: Keypad 0
    KEY_KP_1: int = 321  # Key: Keypad 1
    KEY_KP_2: int = 322  # Key: Keypad 2
    KEY_KP_3: int = 323  # Key: Keypad 3
    KEY_KP_4: int = 324  # Key: Keypad 4
    KEY_KP_5: int = 325  # Key: Keypad 5
    KEY_KP_6: int = 326  # Key: Keypad 6
    KEY_KP_7: int = 327  # Key: Keypad 7
    KEY_KP_8: int = 328  # Key: Keypad 8
    KEY_KP_9: int = 329  # Key: Keypad 9
    KEY_KP_DECIMAL: int = 330  # Key: Keypad .
    KEY_KP_DIVIDE: int = 331  # Key: Keypad /
    KEY_KP_MULTIPLY: int = 332  # Key: Keypad *
    KEY_KP_SUBTRACT: int = 333  # Key: Keypad -
    KEY_KP_ADD: int = 334  # Key: Keypad +
    KEY_KP_ENTER: int = 335  # Key: Keypad Enter
    KEY_KP_EQUAL: int = 336  # Key: Keypad =
    KEY_BACK: int = 4  # Key: Android back button
    KEY_MENU: int = 82  # Key: Android menu button
    KEY_VOLUME_UP: int = 24  # Key: Android volume up button
    KEY_VOLUME_DOWN: int = 25  # Key: Android volume down button


class MouseButton(enum.IntEnum):
    """Mouse buttons"""
    MOUSE_BUTTON_LEFT: int = 0  # Mouse button left
    MOUSE_BUTTON_RIGHT: int = 1  # Mouse button right
    MOUSE_BUTTON_MIDDLE: int = 2  # Mouse button middle (pressed wheel)
    MOUSE_BUTTON_SIDE: int = 3  # Mouse button side (advanced mouse device)
    MOUSE_BUTTON_EXTRA: int = 4  # Mouse button extra (advanced mouse device)
    MOUSE_BUTTON_FORWARD: int = 5  # Mouse button forward (advanced mouse device)
    MOUSE_BUTTON_BACK: int = 6  # Mouse button back (advanced mouse device)


class MouseCursor(enum.IntEnum):
    """Mouse cursor"""
    MOUSE_CURSOR_DEFAULT: int = 0  # Default pointer shape
    MOUSE_CURSOR_ARROW: int = 1  # Arrow shape
    MOUSE_CURSOR_IBEAM: int = 2  # Text writing cursor shape
    MOUSE_CURSOR_CROSSHAIR: int = 3  # Cross shape
    MOUSE_CURSOR_POINTING_HAND: int = 4  # Pointing hand cursor
    MOUSE_CURSOR_RESIZE_EW: int = 5  # Horizontal resize/move arrow shape
    MOUSE_CURSOR_RESIZE_NS: int = 6  # Vertical resize/move arrow shape
    MOUSE_CURSOR_RESIZE_NWSE: int = 7  # Top-left to bottom-right diagonal resize/move arrow shape
    MOUSE_CURSOR_RESIZE_NESW: int = 8  # The top-right to bottom-left diagonal resize/move arrow shape
    MOUSE_CURSOR_RESIZE_ALL: int = 9  # The omnidirectional resize/move cursor shape
    MOUSE_CURSOR_NOT_ALLOWED: int = 10  # The operation-not-allowed shape


class GamepadButton(enum.IntEnum):
    """Gamepad buttons"""
    GAMEPAD_BUTTON_UNKNOWN: int = 0  # Unknown button, just for error checking
    GAMEPAD_BUTTON_LEFT_FACE_UP: int = 1  # Gamepad left DPAD up button
    GAMEPAD_BUTTON_LEFT_FACE_RIGHT: int = 2  # Gamepad left DPAD right button
    GAMEPAD_BUTTON_LEFT_FACE_DOWN: int = 3  # Gamepad left DPAD down button
    GAMEPAD_BUTTON_LEFT_FACE_LEFT: int = 4  # Gamepad left DPAD left button
    GAMEPAD_BUTTON_RIGHT_FACE_UP: int = 5  # Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
    GAMEPAD_BUTTON_RIGHT_FACE_RIGHT: int = 6  # Gamepad right button right (i.e. PS3: Square, Xbox: X)
    GAMEPAD_BUTTON_RIGHT_FACE_DOWN: int = 7  # Gamepad right button down (i.e. PS3: Cross, Xbox: A)
    GAMEPAD_BUTTON_RIGHT_FACE_LEFT: int = 8  # Gamepad right button left (i.e. PS3: Circle, Xbox: B)
    GAMEPAD_BUTTON_LEFT_TRIGGER_1: int = 9  # Gamepad top/back trigger left (first), it could be a trailing button
    GAMEPAD_BUTTON_LEFT_TRIGGER_2: int = 10  # Gamepad top/back trigger left (second), it could be a trailing button
    GAMEPAD_BUTTON_RIGHT_TRIGGER_1: int = 11  # Gamepad top/back trigger right (one), it could be a trailing button
    GAMEPAD_BUTTON_RIGHT_TRIGGER_2: int = 12  # Gamepad top/back trigger right (second), it could be a trailing button
    GAMEPAD_BUTTON_MIDDLE_LEFT: int = 13  # Gamepad center buttons, left one (i.e. PS3: Select)
    GAMEPAD_BUTTON_MIDDLE: int = 14  # Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
    GAMEPAD_BUTTON_MIDDLE_RIGHT: int = 15  # Gamepad center buttons, right one (i.e. PS3: Start)
    GAMEPAD_BUTTON_LEFT_THUMB: int = 16  # Gamepad joystick pressed button left
    GAMEPAD_BUTTON_RIGHT_THUMB: int = 17  # Gamepad joystick pressed button right


class GamepadAxis(enum.IntEnum):
    """Gamepad axis"""
    GAMEPAD_AXIS_LEFT_X: int = 0  # Gamepad left stick X axis
    GAMEPAD_AXIS_LEFT_Y: int = 1  # Gamepad left stick Y axis
    GAMEPAD_AXIS_RIGHT_X: int = 2  # Gamepad right stick X axis
    GAMEPAD_AXIS_RIGHT_Y: int = 3  # Gamepad right stick Y axis
    GAMEPAD_AXIS_LEFT_TRIGGER: int = 4  # Gamepad back trigger left, pressure level: [1..-1]
    GAMEPAD_AXIS_RIGHT_TRIGGER: int = 5  # Gamepad back trigger right, pressure level: [1..-1]


class MaterialMapIndex(enum.IntEnum):
    """Material map index"""
    MATERIAL_MAP_ALBEDO: int = 0  # Albedo material (same as: MATERIAL_MAP_DIFFUSE)
    MATERIAL_MAP_METALNESS: int = 1  # Metalness material (same as: MATERIAL_MAP_SPECULAR)
    MATERIAL_MAP_NORMAL: int = 2  # Normal material
    MATERIAL_MAP_ROUGHNESS: int = 3  # Roughness material
    MATERIAL_MAP_OCCLUSION: int = 4  # Ambient occlusion material
    MATERIAL_MAP_EMISSION: int = 5  # Emission material
    MATERIAL_MAP_HEIGHT: int = 6  # Heightmap material
    MATERIAL_MAP_CUBEMAP: int = 7  # Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
    MATERIAL_MAP_IRRADIANCE: int = 8  # Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
    MATERIAL_MAP_PREFILTER: int = 9  # Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
    MATERIAL_MAP_BRDF: int = 10  # Brdf material


class ShaderLocationIndex(enum.IntEnum):
    """Shader location index"""
    SHADER_LOC_VERTEX_POSITION: int = 0  # Shader location: vertex attribute: position
    SHADER_LOC_VERTEX_TEXCOORD01: int = 1  # Shader location: vertex attribute: texcoord01
    SHADER_LOC_VERTEX_TEXCOORD02: int = 2  # Shader location: vertex attribute: texcoord02
    SHADER_LOC_VERTEX_NORMAL: int = 3  # Shader location: vertex attribute: normal
    SHADER_LOC_VERTEX_TANGENT: int = 4  # Shader location: vertex attribute: tangent
    SHADER_LOC_VERTEX_COLOR: int = 5  # Shader location: vertex attribute: color
    SHADER_LOC_MATRIX_MVP: int = 6  # Shader location: matrix uniform: model-view-projection
    SHADER_LOC_MATRIX_VIEW: int = 7  # Shader location: matrix uniform: view (camera transform)
    SHADER_LOC_MATRIX_PROJECTION: int = 8  # Shader location: matrix uniform: projection
    SHADER_LOC_MATRIX_MODEL: int = 9  # Shader location: matrix uniform: model (transform)
    SHADER_LOC_MATRIX_NORMAL: int = 10  # Shader location: matrix uniform: normal
    SHADER_LOC_VECTOR_VIEW: int = 11  # Shader location: vector uniform: view
    SHADER_LOC_COLOR_DIFFUSE: int = 12  # Shader location: vector uniform: diffuse color
    SHADER_LOC_COLOR_SPECULAR: int = 13  # Shader location: vector uniform: specular color
    SHADER_LOC_COLOR_AMBIENT: int = 14  # Shader location: vector uniform: ambient color
    SHADER_LOC_MAP_ALBEDO: int = 15  # Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
    SHADER_LOC_MAP_METALNESS: int = 16  # Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
    SHADER_LOC_MAP_NORMAL: int = 17  # Shader location: sampler2d texture: normal
    SHADER_LOC_MAP_ROUGHNESS: int = 18  # Shader location: sampler2d texture: roughness
    SHADER_LOC_MAP_OCCLUSION: int = 19  # Shader location: sampler2d texture: occlusion
    SHADER_LOC_MAP_EMISSION: int = 20  # Shader location: sampler2d texture: emission
    SHADER_LOC_MAP_HEIGHT: int = 21  # Shader location: sampler2d texture: height
    SHADER_LOC_MAP_CUBEMAP: int = 22  # Shader location: samplerCube texture: cubemap
    SHADER_LOC_MAP_IRRADIANCE: int = 23  # Shader location: samplerCube texture: irradiance
    SHADER_LOC_MAP_PREFILTER: int = 24  # Shader location: samplerCube texture: prefilter
    SHADER_LOC_MAP_BRDF: int = 25  # Shader location: sampler2d texture: brdf


class ShaderUniformDataType(enum.IntEnum):
    """Shader uniform data type"""
    SHADER_UNIFORM_FLOAT: int = 0  # Shader uniform type: float
    SHADER_UNIFORM_VEC2: int = 1  # Shader uniform type: vec2 (2 float)
    SHADER_UNIFORM_VEC3: int = 2  # Shader uniform type: vec3 (3 float)
    SHADER_UNIFORM_VEC4: int = 3  # Shader uniform type: vec4 (4 float)
    SHADER_UNIFORM_INT: int = 4  # Shader uniform type: int
    SHADER_UNIFORM_IVEC2: int = 5  # Shader uniform type: ivec2 (2 int)
    SHADER_UNIFORM_IVEC3: int = 6  # Shader uniform type: ivec3 (3 int)
    SHADER_UNIFORM_IVEC4: int = 7  # Shader uniform type: ivec4 (4 int)
    SHADER_UNIFORM_SAMPLER2D: int = 8  # Shader uniform type: sampler2d


class ShaderAttributeDataType(enum.IntEnum):
    """Shader attribute data types"""
    SHADER_ATTRIB_FLOAT: int = 0  # Shader attribute type: float
    SHADER_ATTRIB_VEC2: int = 1  # Shader attribute type: vec2 (2 float)
    SHADER_ATTRIB_VEC3: int = 2  # Shader attribute type: vec3 (3 float)
    SHADER_ATTRIB_VEC4: int = 3  # Shader attribute type: vec4 (4 float)


class PixelFormat(enum.IntEnum):
    """Pixel formats"""
    PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: int = 1  # 8 bit per pixel (no alpha)
    PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA: int = 2  # 8*2 bpp (2 channels)
    PIXELFORMAT_UNCOMPRESSED_R5G6B5: int = 3  # 16 bpp
    PIXELFORMAT_UNCOMPRESSED_R8G8B8: int = 4  # 24 bpp
    PIXELFORMAT_UNCOMPRESSED_R5G5B5A1: int = 5  # 16 bpp (1 bit alpha)
    PIXELFORMAT_UNCOMPRESSED_R4G4B4A4: int = 6  # 16 bpp (4 bit alpha)
    PIXELFORMAT_UNCOMPRESSED_R8G8B8A8: int = 7  # 32 bpp
    PIXELFORMAT_UNCOMPRESSED_R32: int = 8  # 32 bpp (1 channel - float)
    PIXELFORMAT_UNCOMPRESSED_R32G32B32: int = 9  # 32*3 bpp (3 channels - float)
    PIXELFORMAT_UNCOMPRESSED_R32G32B32A32: int = 10  # 32*4 bpp (4 channels - float)
    PIXELFORMAT_COMPRESSED_DXT1_RGB: int = 11  # 4 bpp (no alpha)
    PIXELFORMAT_COMPRESSED_DXT1_RGBA: int = 12  # 4 bpp (1 bit alpha)
    PIXELFORMAT_COMPRESSED_DXT3_RGBA: int = 13  # 8 bpp
    PIXELFORMAT_COMPRESSED_DXT5_RGBA: int = 14  # 8 bpp
    PIXELFORMAT_COMPRESSED_ETC1_RGB: int = 15  # 4 bpp
    PIXELFORMAT_COMPRESSED_ETC2_RGB: int = 16  # 4 bpp
    PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA: int = 17  # 8 bpp
    PIXELFORMAT_COMPRESSED_PVRT_RGB: int = 18  # 4 bpp
    PIXELFORMAT_COMPRESSED_PVRT_RGBA: int = 19  # 4 bpp
    PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA: int = 20  # 8 bpp
    PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA: int = 21  # 2 bpp


class TextureFilter(enum.IntEnum):
    """Texture parameters: filter mode"""
    TEXTURE_FILTER_POINT: int = 0  # No filter, just pixel approximation
    TEXTURE_FILTER_BILINEAR: int = 1  # Linear filtering
    TEXTURE_FILTER_TRILINEAR: int = 2  # Trilinear filtering (linear with mipmaps)
    TEXTURE_FILTER_ANISOTROPIC_4X: int = 3  # Anisotropic filtering 4x
    TEXTURE_FILTER_ANISOTROPIC_8X: int = 4  # Anisotropic filtering 8x
    TEXTURE_FILTER_ANISOTROPIC_16X: int = 5  # Anisotropic filtering 16x


class TextureWrap(enum.IntEnum):
    """Texture parameters: wrap mode"""
    TEXTURE_WRAP_REPEAT: int = 0  # Repeats texture in tiled mode
    TEXTURE_WRAP_CLAMP: int = 1  # Clamps texture to edge pixel in tiled mode
    TEXTURE_WRAP_MIRROR_REPEAT: int = 2  # Mirrors and repeats the texture in tiled mode
    TEXTURE_WRAP_MIRROR_CLAMP: int = 3  # Mirrors and clamps to border the texture in tiled mode


class CubemapLayout(enum.IntEnum):
    """Cubemap layouts"""
    CUBEMAP_LAYOUT_AUTO_DETECT: int = 0  # Automatically detect layout type
    CUBEMAP_LAYOUT_LINE_VERTICAL: int = 1  # Layout is defined by a vertical line with faces
    CUBEMAP_LAYOUT_LINE_HORIZONTAL: int = 2  # Layout is defined by a horizontal line with faces
    CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR: int = 3  # Layout is defined by a 3x4 cross with cubemap faces
    CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE: int = 4  # Layout is defined by a 4x3 cross with cubemap faces
    CUBEMAP_LAYOUT_PANORAMA: int = 5  # Layout is defined by a panorama image (equirrectangular map)


class FontType(enum.IntEnum):
    """Font type, defines generation method"""
    FONT_DEFAULT: int = 0  # Default font generation, anti-aliased
    FONT_BITMAP: int = 1  # Bitmap font generation, no anti-aliasing
    FONT_SDF: int = 2  # SDF font generation, requires external shader


class BlendMode(enum.IntEnum):
    """Color blending modes (pre-defined)"""
    BLEND_ALPHA: int = 0  # Blend textures considering alpha (default)
    BLEND_ADDITIVE: int = 1  # Blend textures adding colors
    BLEND_MULTIPLIED: int = 2  # Blend textures multiplying colors
    BLEND_ADD_COLORS: int = 3  # Blend textures adding colors (alternative)
    BLEND_SUBTRACT_COLORS: int = 4  # Blend textures subtracting colors (alternative)
    BLEND_ALPHA_PREMULTIPLY: int = 5  # Blend premultiplied textures considering alpha
    BLEND_CUSTOM: int = 6  # Blend textures using custom src/dst factors (use rlSetBlendFactors())
    BLEND_CUSTOM_SEPARATE: int = 7  # Blend textures using custom rgb/alpha separate src/dst factors (use rlSetBlendFactorsSeparate())


class Gesture(enum.IntEnum):
    """Gesture"""
    GESTURE_NONE: int = 0  # No gesture
    GESTURE_TAP: int = 1  # Tap gesture
    GESTURE_DOUBLETAP: int = 2  # Double tap gesture
    GESTURE_HOLD: int = 4  # Hold gesture
    GESTURE_DRAG: int = 8  # Drag gesture
    GESTURE_SWIPE_RIGHT: int = 16  # Swipe right gesture
    GESTURE_SWIPE_LEFT: int = 32  # Swipe left gesture
    GESTURE_SWIPE_UP: int = 64  # Swipe up gesture
    GESTURE_SWIPE_DOWN: int = 128  # Swipe down gesture
    GESTURE_PINCH_IN: int = 256  # Pinch in gesture
    GESTURE_PINCH_OUT: int = 512  # Pinch out gesture


class CameraMode(enum.IntEnum):
    """Camera system modes"""
    CAMERA_CUSTOM: int = 0  # Custom camera
    CAMERA_FREE: int = 1  # Free camera
    CAMERA_ORBITAL: int = 2  # Orbital camera
    CAMERA_FIRST_PERSON: int = 3  # First person camera
    CAMERA_THIRD_PERSON: int = 4  # Third person camera


class CameraProjection(enum.IntEnum):
    """Camera projection"""
    CAMERA_PERSPECTIVE: int = 0  # Perspective projection
    CAMERA_ORTHOGRAPHIC: int = 1  # Orthographic projection


class NPatchLayout(enum.IntEnum):
    """N-patch layout"""
    NPATCH_NINE_PATCH: int = 0  # Npatch layout: 3x3 tiles
    NPATCH_THREE_PATCH_VERTICAL: int = 1  # Npatch layout: 1x3 tiles
    NPATCH_THREE_PATCH_HORIZONTAL: int = 2  # Npatch layout: 3x1 tiles


RAYLIB_VERSION_MAJOR: int = 4
RAYLIB_VERSION_MINOR: int = 6
RAYLIB_VERSION_PATCH: int = 0
RAYLIB_VERSION: str = "4.6-dev"
PI: float = 3.141592653589793
DEG2RAD: float = (PI/180.0)
RAD2DEG: float = (180.0/PI)
def init_window(width: int, height: int, title: str):
    title_ = _mod._malloc(len(title) + 1)
    _mod.stringToUTF8(title, title_, len(title) + 1)
    """Initialize window and OpenGL context"""
    _mod._InitWindow(width, height, title_)
    _mod._free(title_)


def window_should_close() -> int:
    """Check if KEY_ESCAPE pressed or Close icon pressed"""
    return_interface = _mod._WindowShouldClose()
    return return_interface


def close_window():
    """Close window and unload OpenGL context"""
    _mod._CloseWindow()


def is_window_ready() -> int:
    """Check if window has been initialized successfully"""
    return_interface = _mod._IsWindowReady()
    return return_interface


def is_window_fullscreen() -> int:
    """Check if window is currently fullscreen"""
    return_interface = _mod._IsWindowFullscreen()
    return return_interface


def is_window_hidden() -> int:
    """Check if window is currently hidden (only PLATFORM_DESKTOP)"""
    return_interface = _mod._IsWindowHidden()
    return return_interface


def is_window_minimized() -> int:
    """Check if window is currently minimized (only PLATFORM_DESKTOP)"""
    return_interface = _mod._IsWindowMinimized()
    return return_interface


def is_window_maximized() -> int:
    """Check if window is currently maximized (only PLATFORM_DESKTOP)"""
    return_interface = _mod._IsWindowMaximized()
    return return_interface


def is_window_focused() -> int:
    """Check if window is currently focused (only PLATFORM_DESKTOP)"""
    return_interface = _mod._IsWindowFocused()
    return return_interface


def is_window_resized() -> int:
    """Check if window has been resized last frame"""
    return_interface = _mod._IsWindowResized()
    return return_interface


def is_window_state(flag: int) -> int:
    """Check if one specific window flag is enabled"""
    return_interface = _mod._IsWindowState(flag)
    return return_interface


def set_window_state(flags: int):
    """Set window configuration state using flags (only PLATFORM_DESKTOP)"""
    _mod._SetWindowState(flags)


def clear_window_state(flags: int):
    """Clear window configuration state flags"""
    _mod._ClearWindowState(flags)


def toggle_fullscreen():
    """Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP)"""
    _mod._ToggleFullscreen()


def maximize_window():
    """Set window state: maximized, if resizable (only PLATFORM_DESKTOP)"""
    _mod._MaximizeWindow()


def minimize_window():
    """Set window state: minimized, if resizable (only PLATFORM_DESKTOP)"""
    _mod._MinimizeWindow()


def restore_window():
    """Set window state: not minimized/maximized (only PLATFORM_DESKTOP)"""
    _mod._RestoreWindow()


def set_window_icon(image: Image):
    """Set icon for window (single image, RGBA 32bit, only PLATFORM_DESKTOP)"""
    _mod._SetWindowIcon(image._address)


def set_window_icons(images: int, count: int):
    """Set icon for window (multiple images, RGBA 32bit, only PLATFORM_DESKTOP)"""
    _mod._SetWindowIcons(images, count)


def set_window_title(title: str):
    title_ = _mod._malloc(len(title) + 1)
    _mod.stringToUTF8(title, title_, len(title) + 1)
    """Set title for window (only PLATFORM_DESKTOP)"""
    _mod._SetWindowTitle(title_)
    _mod._free(title_)


def set_window_position(x: int, y: int):
    """Set window position on screen (only PLATFORM_DESKTOP)"""
    _mod._SetWindowPosition(x, y)


def set_window_monitor(monitor: int):
    """Set monitor for the current window (fullscreen mode)"""
    _mod._SetWindowMonitor(monitor)


def set_window_min_size(width: int, height: int):
    """Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)"""
    _mod._SetWindowMinSize(width, height)


def set_window_size(width: int, height: int):
    """Set window dimensions"""
    _mod._SetWindowSize(width, height)


def set_window_opacity(opacity: float):
    """Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)"""
    _mod._SetWindowOpacity(opacity)


def set_window_focused():
    """Set window focused (only PLATFORM_DESKTOP)"""
    _mod._SetWindowFocused()


def get_window_handle() -> int:
    """Get native window handle"""
    return_interface = _mod._GetWindowHandle()
    return return_interface


def get_screen_width() -> int:
    """Get current screen width"""
    return_interface = _mod._GetScreenWidth()
    return return_interface


def get_screen_height() -> int:
    """Get current screen height"""
    return_interface = _mod._GetScreenHeight()
    return return_interface


def get_render_width() -> int:
    """Get current render width (it considers HiDPI)"""
    return_interface = _mod._GetRenderWidth()
    return return_interface


def get_render_height() -> int:
    """Get current render height (it considers HiDPI)"""
    return_interface = _mod._GetRenderHeight()
    return return_interface


def get_monitor_count() -> int:
    """Get number of connected monitors"""
    return_interface = _mod._GetMonitorCount()
    return return_interface


def get_current_monitor() -> int:
    """Get current connected monitor"""
    return_interface = _mod._GetCurrentMonitor()
    return return_interface


def get_monitor_position(monitor: int) -> Vector2:
    Vector2_ = Vector2()
    """Get specified monitor position"""
    _mod._GetMonitorPosition(Vector2_._address, monitor)
    return Vector2_


def get_monitor_width(monitor: int) -> int:
    """Get specified monitor width (current video mode used by monitor)"""
    return_interface = _mod._GetMonitorWidth(monitor)
    return return_interface


def get_monitor_height(monitor: int) -> int:
    """Get specified monitor height (current video mode used by monitor)"""
    return_interface = _mod._GetMonitorHeight(monitor)
    return return_interface


def get_monitor_physical_width(monitor: int) -> int:
    """Get specified monitor physical width in millimetres"""
    return_interface = _mod._GetMonitorPhysicalWidth(monitor)
    return return_interface


def get_monitor_physical_height(monitor: int) -> int:
    """Get specified monitor physical height in millimetres"""
    return_interface = _mod._GetMonitorPhysicalHeight(monitor)
    return return_interface


def get_monitor_refresh_rate(monitor: int) -> int:
    """Get specified monitor refresh rate"""
    return_interface = _mod._GetMonitorRefreshRate(monitor)
    return return_interface


def get_window_position() -> Vector2:
    Vector2_ = Vector2()
    """Get window position XY on monitor"""
    _mod._GetWindowPosition(Vector2_._address)
    return Vector2_


def get_window_scale_dpi() -> Vector2:
    Vector2_ = Vector2()
    """Get window scale DPI factor"""
    _mod._GetWindowScaleDPI(Vector2_._address)
    return Vector2_


def get_monitor_name(monitor: int) -> int:
    """Get the human-readable, UTF-8 encoded name of the primary monitor"""
    return_interface = _mod._GetMonitorName(monitor)
    return return_interface


def set_clipboard_text(text: str):
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Set clipboard text content"""
    _mod._SetClipboardText(text_)
    _mod._free(text_)


def get_clipboard_text() -> int:
    """Get clipboard text content"""
    return_interface = _mod._GetClipboardText()
    return return_interface


def enable_event_waiting():
    """Enable waiting for events on EndDrawing(), no automatic event polling"""
    _mod._EnableEventWaiting()


def disable_event_waiting():
    """Disable waiting for events on EndDrawing(), automatic events polling"""
    _mod._DisableEventWaiting()


def swap_screen_buffer():
    """Swap back buffer with front buffer (screen drawing)"""
    _mod._SwapScreenBuffer()


def poll_input_events():
    """Register all input events"""
    _mod._PollInputEvents()


def wait_time(seconds: float):
    """Wait for some time (halt program execution)"""
    _mod._WaitTime(seconds)


def show_cursor():
    """Shows cursor"""
    _mod._ShowCursor()


def hide_cursor():
    """Hides cursor"""
    _mod._HideCursor()


def is_cursor_hidden() -> int:
    """Check if cursor is not visible"""
    return_interface = _mod._IsCursorHidden()
    return return_interface


def enable_cursor():
    """Enables cursor (unlock cursor)"""
    _mod._EnableCursor()


def disable_cursor():
    """Disables cursor (lock cursor)"""
    _mod._DisableCursor()


def is_cursor_on_screen() -> int:
    """Check if cursor is on the screen"""
    return_interface = _mod._IsCursorOnScreen()
    return return_interface


def clear_background(color: Color):
    """Set background color (framebuffer clear color)"""
    _mod._ClearBackground(color._address)


def begin_drawing():
    """Setup canvas (framebuffer) to start drawing"""
    _mod._BeginDrawing()


def end_drawing():
    """End canvas drawing and swap buffers (double buffering)"""
    _mod._EndDrawing()


def begin_mode_2d(camera: Camera2D):
    """Begin 2D mode with custom camera (2D)"""
    _mod._BeginMode2D(camera._address)


def end_mode_2d():
    """Ends 2D mode with custom camera"""
    _mod._EndMode2D()


def begin_mode_3d(camera: Camera3D):
    """Begin 3D mode with custom camera (3D)"""
    _mod._BeginMode3D(camera._address)


def end_mode_3d():
    """Ends 3D mode and returns to default 2D orthographic mode"""
    _mod._EndMode3D()


def begin_texture_mode(target: RenderTexture2D):
    """Begin drawing to render texture"""
    _mod._BeginTextureMode(target._address)


def end_texture_mode():
    """Ends drawing to render texture"""
    _mod._EndTextureMode()


def begin_shader_mode(shader: Shader):
    """Begin custom shader drawing"""
    _mod._BeginShaderMode(shader._address)


def end_shader_mode():
    """End custom shader drawing (use default shader)"""
    _mod._EndShaderMode()


def begin_blend_mode(mode: int):
    """Begin blending mode (alpha, additive, multiplied, subtract, custom)"""
    _mod._BeginBlendMode(mode)


def end_blend_mode():
    """End blending mode (reset to default: alpha blending)"""
    _mod._EndBlendMode()


def begin_scissor_mode(x: int, y: int, width: int, height: int):
    """Begin scissor mode (define screen area for following drawing)"""
    _mod._BeginScissorMode(x, y, width, height)


def end_scissor_mode():
    """End scissor mode"""
    _mod._EndScissorMode()


def begin_vr_stereo_mode(config: VrStereoConfig):
    """Begin stereo rendering (requires VR simulator)"""
    _mod._BeginVrStereoMode(config._address)


def end_vr_stereo_mode():
    """End stereo rendering (requires VR simulator)"""
    _mod._EndVrStereoMode()


def load_vr_stereo_config(device: VrDeviceInfo) -> VrStereoConfig:
    VrStereoConfig_ = VrStereoConfig()
    """Load VR stereo config for VR simulator device parameters"""
    _mod._LoadVrStereoConfig(VrStereoConfig_._address, device._address)
    return VrStereoConfig_


def unload_vr_stereo_config(config: VrStereoConfig):
    """Unload VR stereo config"""
    _mod._UnloadVrStereoConfig(config._address)


def load_shader(vsFileName: str, fsFileName: str) -> Shader:
    Shader_ = Shader()
    vsFileName_ = _mod._malloc(len(vsFileName) + 1)
    _mod.stringToUTF8(vsFileName, vsFileName_, len(vsFileName) + 1)
    fsFileName_ = _mod._malloc(len(fsFileName) + 1)
    _mod.stringToUTF8(fsFileName, fsFileName_, len(fsFileName) + 1)
    """Load shader from files and bind default locations"""
    _mod._LoadShader(Shader_._address, vsFileName_, fsFileName_)
    _mod._free(vsFileName_)
    _mod._free(fsFileName_)
    return Shader_


def load_shader_from_memory(vsCode: str, fsCode: str) -> Shader:
    Shader_ = Shader()
    vsCode_ = _mod._malloc(len(vsCode) + 1)
    _mod.stringToUTF8(vsCode, vsCode_, len(vsCode) + 1)
    fsCode_ = _mod._malloc(len(fsCode) + 1)
    _mod.stringToUTF8(fsCode, fsCode_, len(fsCode) + 1)
    """Load shader from code strings and bind default locations"""
    _mod._LoadShaderFromMemory(Shader_._address, vsCode_, fsCode_)
    _mod._free(vsCode_)
    _mod._free(fsCode_)
    return Shader_


def is_shader_ready(shader: Shader) -> int:
    """Check if a shader is ready"""
    return_interface = _mod._IsShaderReady(shader._address)
    return return_interface


def get_shader_location(shader: Shader, uniformName: str) -> int:
    uniformName_ = _mod._malloc(len(uniformName) + 1)
    _mod.stringToUTF8(uniformName, uniformName_, len(uniformName) + 1)
    """Get shader uniform location"""
    return_interface = _mod._GetShaderLocation(shader._address, uniformName_)
    _mod._free(uniformName_)
    return return_interface


def get_shader_location_attrib(shader: Shader, attribName: str) -> int:
    attribName_ = _mod._malloc(len(attribName) + 1)
    _mod.stringToUTF8(attribName, attribName_, len(attribName) + 1)
    """Get shader attribute location"""
    return_interface = _mod._GetShaderLocationAttrib(shader._address, attribName_)
    _mod._free(attribName_)
    return return_interface


def set_shader_value(shader: Shader, locIndex: int, value: int, uniformType: int):
    """Set shader uniform value"""
    _mod._SetShaderValue(shader._address, locIndex, value, uniformType)


def set_shader_value_v(shader: Shader, locIndex: int, value: int, uniformType: int, count: int):
    """Set shader uniform value vector"""
    _mod._SetShaderValueV(shader._address, locIndex, value, uniformType, count)


def set_shader_value_matrix(shader: Shader, locIndex: int, mat: Matrix):
    """Set shader uniform value (matrix 4x4)"""
    _mod._SetShaderValueMatrix(shader._address, locIndex, mat._address)


def set_shader_value_texture(shader: Shader, locIndex: int, texture: Texture2D):
    """Set shader uniform value for texture (sampler2d)"""
    _mod._SetShaderValueTexture(shader._address, locIndex, texture._address)


def unload_shader(shader: Shader):
    """Unload shader from GPU memory (VRAM)"""
    _mod._UnloadShader(shader._address)


def get_mouse_ray(mousePosition: Vector2, camera: Camera) -> Ray:
    Ray_ = Ray()
    """Get a ray trace from mouse position"""
    _mod._GetMouseRay(Ray_._address, mousePosition._address, camera._address)
    return Ray_


def get_camera_matrix(camera: Camera) -> Matrix:
    Matrix_ = Matrix()
    """Get camera transform matrix (view matrix)"""
    _mod._GetCameraMatrix(Matrix_._address, camera._address)
    return Matrix_


def get_camera_matrix_2d(camera: Camera2D) -> Matrix:
    Matrix_ = Matrix()
    """Get camera 2d transform matrix"""
    _mod._GetCameraMatrix2D(Matrix_._address, camera._address)
    return Matrix_


def get_world_to_screen(position: Vector3, camera: Camera) -> Vector2:
    Vector2_ = Vector2()
    """Get the screen space position for a 3d world space position"""
    _mod._GetWorldToScreen(Vector2_._address, position._address, camera._address)
    return Vector2_


def get_screen_to_world_2d(position: Vector2, camera: Camera2D) -> Vector2:
    Vector2_ = Vector2()
    """Get the world space position for a 2d camera screen space position"""
    _mod._GetScreenToWorld2D(Vector2_._address, position._address, camera._address)
    return Vector2_


def get_world_to_screen_ex(position: Vector3, camera: Camera, width: int, height: int) -> Vector2:
    Vector2_ = Vector2()
    """Get size position for a 3d world space position"""
    _mod._GetWorldToScreenEx(Vector2_._address, position._address, camera._address, width, height)
    return Vector2_


def get_world_to_screen_2d(position: Vector2, camera: Camera2D) -> Vector2:
    Vector2_ = Vector2()
    """Get the screen space position for a 2d camera world space position"""
    _mod._GetWorldToScreen2D(Vector2_._address, position._address, camera._address)
    return Vector2_


def set_target_fps(fps: int):
    """Set target FPS (maximum)"""
    _mod._SetTargetFPS(fps)


def get_fps() -> int:
    """Get current FPS"""
    return_interface = _mod._GetFPS()
    return return_interface


def get_frame_time() -> float:
    """Get time in seconds for last frame drawn (delta time)"""
    return_interface = _mod._GetFrameTime()
    return return_interface


def get_time() -> float:
    """Get elapsed time in seconds since InitWindow()"""
    return_interface = _mod._GetTime()
    return return_interface


def get_random_value(min: int, max: int) -> int:
    """Get a random value between min and max (both included)"""
    return_interface = _mod._GetRandomValue(min, max)
    return return_interface


def set_random_seed(seed: int):
    """Set the seed for the random number generator"""
    _mod._SetRandomSeed(seed)


def take_screenshot(fileName: str):
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Takes a screenshot of current screen (filename extension defines format)"""
    _mod._TakeScreenshot(fileName_)
    _mod._free(fileName_)


def set_config_flags(flags: int):
    """Setup init configuration flags (view FLAGS)"""
    _mod._SetConfigFlags(flags)


def set_trace_log_level(logLevel: int):
    """Set the current threshold (minimum) log level"""
    _mod._SetTraceLogLevel(logLevel)


def mem_alloc(size: int) -> int:
    """Internal memory allocator"""
    return_interface = _mod._MemAlloc(size)
    return return_interface


def mem_realloc(ptr: int, size: int) -> int:
    """Internal memory reallocator"""
    return_interface = _mod._MemRealloc(ptr, size)
    return return_interface


def mem_free(ptr: int):
    """Internal memory free"""
    _mod._MemFree(ptr)


def open_url(url: str):
    url_ = _mod._malloc(len(url) + 1)
    _mod.stringToUTF8(url, url_, len(url) + 1)
    """Open URL with default system browser (if available)"""
    _mod._OpenURL(url_)
    _mod._free(url_)


def load_file_data(fileName: str, bytesRead: int) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load file data as byte array (read)"""
    return_interface = _mod._LoadFileData(fileName_, bytesRead)
    _mod._free(fileName_)
    return return_interface


def unload_file_data(data: int):
    """Unload file data allocated by LoadFileData()"""
    _mod._UnloadFileData(data)


def save_file_data(fileName: str, data: int, bytesToWrite: int) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Save data to file from byte array (write), returns true on success"""
    return_interface = _mod._SaveFileData(fileName_, data, bytesToWrite)
    _mod._free(fileName_)
    return return_interface


def export_data_as_code(data: int, size: int, fileName: str) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Export data to code (.h), returns true on success"""
    return_interface = _mod._ExportDataAsCode(data, size, fileName_)
    _mod._free(fileName_)
    return return_interface


def load_file_text(fileName: str) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load text data from file (read), returns a '\0' terminated string"""
    return_interface = _mod._LoadFileText(fileName_)
    _mod._free(fileName_)
    return return_interface


def unload_file_text(text: int):
    """Unload file text data allocated by LoadFileText()"""
    _mod._UnloadFileText(text)


def save_file_text(fileName: str, text: int) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Save text data to file (write), string must be '\0' terminated, returns true on success"""
    return_interface = _mod._SaveFileText(fileName_, text)
    _mod._free(fileName_)
    return return_interface


def file_exists(fileName: str) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Check if file exists"""
    return_interface = _mod._FileExists(fileName_)
    _mod._free(fileName_)
    return return_interface


def directory_exists(dirPath: str) -> int:
    dirPath_ = _mod._malloc(len(dirPath) + 1)
    _mod.stringToUTF8(dirPath, dirPath_, len(dirPath) + 1)
    """Check if a directory path exists"""
    return_interface = _mod._DirectoryExists(dirPath_)
    _mod._free(dirPath_)
    return return_interface


def is_file_extension(fileName: str, ext: str) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    ext_ = _mod._malloc(len(ext) + 1)
    _mod.stringToUTF8(ext, ext_, len(ext) + 1)
    """Check file extension (including point: .png, .wav)"""
    return_interface = _mod._IsFileExtension(fileName_, ext_)
    _mod._free(fileName_)
    _mod._free(ext_)
    return return_interface


def get_file_length(fileName: str) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)"""
    return_interface = _mod._GetFileLength(fileName_)
    _mod._free(fileName_)
    return return_interface


def get_file_extension(fileName: str) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Get pointer to extension for a filename string (includes dot: '.png')"""
    return_interface = _mod._GetFileExtension(fileName_)
    _mod._free(fileName_)
    return return_interface


def get_file_name(filePath: str) -> int:
    filePath_ = _mod._malloc(len(filePath) + 1)
    _mod.stringToUTF8(filePath, filePath_, len(filePath) + 1)
    """Get pointer to filename for a path string"""
    return_interface = _mod._GetFileName(filePath_)
    _mod._free(filePath_)
    return return_interface


def get_file_name_without_ext(filePath: str) -> int:
    filePath_ = _mod._malloc(len(filePath) + 1)
    _mod.stringToUTF8(filePath, filePath_, len(filePath) + 1)
    """Get filename string without extension (uses static string)"""
    return_interface = _mod._GetFileNameWithoutExt(filePath_)
    _mod._free(filePath_)
    return return_interface


def get_directory_path(filePath: str) -> int:
    filePath_ = _mod._malloc(len(filePath) + 1)
    _mod.stringToUTF8(filePath, filePath_, len(filePath) + 1)
    """Get full path for a given fileName with path (uses static string)"""
    return_interface = _mod._GetDirectoryPath(filePath_)
    _mod._free(filePath_)
    return return_interface


def get_prev_directory_path(dirPath: str) -> int:
    dirPath_ = _mod._malloc(len(dirPath) + 1)
    _mod.stringToUTF8(dirPath, dirPath_, len(dirPath) + 1)
    """Get previous directory path for a given path (uses static string)"""
    return_interface = _mod._GetPrevDirectoryPath(dirPath_)
    _mod._free(dirPath_)
    return return_interface


def get_working_directory() -> int:
    """Get current working directory (uses static string)"""
    return_interface = _mod._GetWorkingDirectory()
    return return_interface


def get_application_directory() -> int:
    """Get the directory if the running application (uses static string)"""
    return_interface = _mod._GetApplicationDirectory()
    return return_interface


def change_directory(dir: str) -> int:
    dir_ = _mod._malloc(len(dir) + 1)
    _mod.stringToUTF8(dir, dir_, len(dir) + 1)
    """Change working directory, return true on success"""
    return_interface = _mod._ChangeDirectory(dir_)
    _mod._free(dir_)
    return return_interface


def is_path_file(path: str) -> int:
    path_ = _mod._malloc(len(path) + 1)
    _mod.stringToUTF8(path, path_, len(path) + 1)
    """Check if a given path is a file or a directory"""
    return_interface = _mod._IsPathFile(path_)
    _mod._free(path_)
    return return_interface


def load_directory_files(dirPath: str) -> FilePathList:
    FilePathList_ = FilePathList()
    dirPath_ = _mod._malloc(len(dirPath) + 1)
    _mod.stringToUTF8(dirPath, dirPath_, len(dirPath) + 1)
    """Load directory filepaths"""
    _mod._LoadDirectoryFiles(FilePathList_._address, dirPath_)
    _mod._free(dirPath_)
    return FilePathList_


def load_directory_files_ex(basePath: str, filter: str, scanSubdirs: int) -> FilePathList:
    FilePathList_ = FilePathList()
    basePath_ = _mod._malloc(len(basePath) + 1)
    _mod.stringToUTF8(basePath, basePath_, len(basePath) + 1)
    filter_ = _mod._malloc(len(filter) + 1)
    _mod.stringToUTF8(filter, filter_, len(filter) + 1)
    """Load directory filepaths with extension filtering and recursive directory scan"""
    _mod._LoadDirectoryFilesEx(FilePathList_._address, basePath_, filter_, scanSubdirs)
    _mod._free(basePath_)
    _mod._free(filter_)
    return FilePathList_


def unload_directory_files(files: FilePathList):
    """Unload filepaths"""
    _mod._UnloadDirectoryFiles(files._address)


def is_file_dropped() -> int:
    """Check if a file has been dropped into window"""
    return_interface = _mod._IsFileDropped()
    return return_interface


def load_dropped_files() -> FilePathList:
    FilePathList_ = FilePathList()
    """Load dropped filepaths"""
    _mod._LoadDroppedFiles(FilePathList_._address)
    return FilePathList_


def unload_dropped_files(files: FilePathList):
    """Unload dropped filepaths"""
    _mod._UnloadDroppedFiles(files._address)


def get_file_mod_time(fileName: str) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Get file modification time (last write time)"""
    return_interface = _mod._GetFileModTime(fileName_)
    _mod._free(fileName_)
    return return_interface


def compress_data(data: int, dataSize: int, compDataSize: int) -> int:
    """Compress data (DEFLATE algorithm), memory must be MemFree()"""
    return_interface = _mod._CompressData(data, dataSize, compDataSize)
    return return_interface


def decompress_data(compData: int, compDataSize: int, dataSize: int) -> int:
    """Decompress data (DEFLATE algorithm), memory must be MemFree()"""
    return_interface = _mod._DecompressData(compData, compDataSize, dataSize)
    return return_interface


def encode_data_base64(data: int, dataSize: int, outputSize: int) -> int:
    """Encode data to Base64 string, memory must be MemFree()"""
    return_interface = _mod._EncodeDataBase64(data, dataSize, outputSize)
    return return_interface


def decode_data_base64(data: int, outputSize: int) -> int:
    """Decode Base64 string data, memory must be MemFree()"""
    return_interface = _mod._DecodeDataBase64(data, outputSize)
    return return_interface


def is_key_pressed(key: int) -> int:
    """Check if a key has been pressed once"""
    return_interface = _mod._IsKeyPressed(key)
    return return_interface


def is_key_down(key: int) -> int:
    """Check if a key is being pressed"""
    return_interface = _mod._IsKeyDown(key)
    return return_interface


def is_key_released(key: int) -> int:
    """Check if a key has been released once"""
    return_interface = _mod._IsKeyReleased(key)
    return return_interface


def is_key_up(key: int) -> int:
    """Check if a key is NOT being pressed"""
    return_interface = _mod._IsKeyUp(key)
    return return_interface


def set_exit_key(key: int):
    """Set a custom key to exit program (default is ESC)"""
    _mod._SetExitKey(key)


def get_key_pressed() -> int:
    """Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty"""
    return_interface = _mod._GetKeyPressed()
    return return_interface


def get_char_pressed() -> int:
    """Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty"""
    return_interface = _mod._GetCharPressed()
    return return_interface


def is_gamepad_available(gamepad: int) -> int:
    """Check if a gamepad is available"""
    return_interface = _mod._IsGamepadAvailable(gamepad)
    return return_interface


def get_gamepad_name(gamepad: int) -> int:
    """Get gamepad internal name id"""
    return_interface = _mod._GetGamepadName(gamepad)
    return return_interface


def is_gamepad_button_pressed(gamepad: int, button: int) -> int:
    """Check if a gamepad button has been pressed once"""
    return_interface = _mod._IsGamepadButtonPressed(gamepad, button)
    return return_interface


def is_gamepad_button_down(gamepad: int, button: int) -> int:
    """Check if a gamepad button is being pressed"""
    return_interface = _mod._IsGamepadButtonDown(gamepad, button)
    return return_interface


def is_gamepad_button_released(gamepad: int, button: int) -> int:
    """Check if a gamepad button has been released once"""
    return_interface = _mod._IsGamepadButtonReleased(gamepad, button)
    return return_interface


def is_gamepad_button_up(gamepad: int, button: int) -> int:
    """Check if a gamepad button is NOT being pressed"""
    return_interface = _mod._IsGamepadButtonUp(gamepad, button)
    return return_interface


def get_gamepad_button_pressed() -> int:
    """Get the last gamepad button pressed"""
    return_interface = _mod._GetGamepadButtonPressed()
    return return_interface


def get_gamepad_axis_count(gamepad: int) -> int:
    """Get gamepad axis count for a gamepad"""
    return_interface = _mod._GetGamepadAxisCount(gamepad)
    return return_interface


def get_gamepad_axis_movement(gamepad: int, axis: int) -> float:
    """Get axis movement value for a gamepad axis"""
    return_interface = _mod._GetGamepadAxisMovement(gamepad, axis)
    return return_interface


def set_gamepad_mappings(mappings: str) -> int:
    mappings_ = _mod._malloc(len(mappings) + 1)
    _mod.stringToUTF8(mappings, mappings_, len(mappings) + 1)
    """Set internal gamepad mappings (SDL_GameControllerDB)"""
    return_interface = _mod._SetGamepadMappings(mappings_)
    _mod._free(mappings_)
    return return_interface


def is_mouse_button_pressed(button: int) -> int:
    """Check if a mouse button has been pressed once"""
    return_interface = _mod._IsMouseButtonPressed(button)
    return return_interface


def is_mouse_button_down(button: int) -> int:
    """Check if a mouse button is being pressed"""
    return_interface = _mod._IsMouseButtonDown(button)
    return return_interface


def is_mouse_button_released(button: int) -> int:
    """Check if a mouse button has been released once"""
    return_interface = _mod._IsMouseButtonReleased(button)
    return return_interface


def is_mouse_button_up(button: int) -> int:
    """Check if a mouse button is NOT being pressed"""
    return_interface = _mod._IsMouseButtonUp(button)
    return return_interface


def get_mouse_x() -> int:
    """Get mouse position X"""
    return_interface = _mod._GetMouseX()
    return return_interface


def get_mouse_y() -> int:
    """Get mouse position Y"""
    return_interface = _mod._GetMouseY()
    return return_interface


def get_mouse_position() -> Vector2:
    Vector2_ = Vector2()
    """Get mouse position XY"""
    _mod._GetMousePosition(Vector2_._address)
    return Vector2_


def get_mouse_delta() -> Vector2:
    Vector2_ = Vector2()
    """Get mouse delta between frames"""
    _mod._GetMouseDelta(Vector2_._address)
    return Vector2_


def set_mouse_position(x: int, y: int):
    """Set mouse position XY"""
    _mod._SetMousePosition(x, y)


def set_mouse_offset(offsetX: int, offsetY: int):
    """Set mouse offset"""
    _mod._SetMouseOffset(offsetX, offsetY)


def set_mouse_scale(scaleX: float, scaleY: float):
    """Set mouse scaling"""
    _mod._SetMouseScale(scaleX, scaleY)


def get_mouse_wheel_move() -> float:
    """Get mouse wheel movement for X or Y, whichever is larger"""
    return_interface = _mod._GetMouseWheelMove()
    return return_interface


def get_mouse_wheel_move_v() -> Vector2:
    Vector2_ = Vector2()
    """Get mouse wheel movement for both X and Y"""
    _mod._GetMouseWheelMoveV(Vector2_._address)
    return Vector2_


def set_mouse_cursor(cursor: int):
    """Set mouse cursor"""
    _mod._SetMouseCursor(cursor)


def get_touch_x() -> int:
    """Get touch position X for touch point 0 (relative to screen size)"""
    return_interface = _mod._GetTouchX()
    return return_interface


def get_touch_y() -> int:
    """Get touch position Y for touch point 0 (relative to screen size)"""
    return_interface = _mod._GetTouchY()
    return return_interface


def get_touch_position(index: int) -> Vector2:
    Vector2_ = Vector2()
    """Get touch position XY for a touch point index (relative to screen size)"""
    _mod._GetTouchPosition(Vector2_._address, index)
    return Vector2_


def get_touch_point_id(index: int) -> int:
    """Get touch point identifier for given index"""
    return_interface = _mod._GetTouchPointId(index)
    return return_interface


def get_touch_point_count() -> int:
    """Get number of touch points"""
    return_interface = _mod._GetTouchPointCount()
    return return_interface


def set_gestures_enabled(flags: int):
    """Enable a set of gestures using flags"""
    _mod._SetGesturesEnabled(flags)


def is_gesture_detected(gesture: int) -> int:
    """Check if a gesture have been detected"""
    return_interface = _mod._IsGestureDetected(gesture)
    return return_interface


def get_gesture_detected() -> int:
    """Get latest detected gesture"""
    return_interface = _mod._GetGestureDetected()
    return return_interface


def get_gesture_hold_duration() -> float:
    """Get gesture hold time in milliseconds"""
    return_interface = _mod._GetGestureHoldDuration()
    return return_interface


def get_gesture_drag_vector() -> Vector2:
    Vector2_ = Vector2()
    """Get gesture drag vector"""
    _mod._GetGestureDragVector(Vector2_._address)
    return Vector2_


def get_gesture_drag_angle() -> float:
    """Get gesture drag angle"""
    return_interface = _mod._GetGestureDragAngle()
    return return_interface


def get_gesture_pinch_vector() -> Vector2:
    Vector2_ = Vector2()
    """Get gesture pinch delta"""
    _mod._GetGesturePinchVector(Vector2_._address)
    return Vector2_


def get_gesture_pinch_angle() -> float:
    """Get gesture pinch angle"""
    return_interface = _mod._GetGesturePinchAngle()
    return return_interface


def update_camera(camera: int, mode: int):
    """Update camera position for selected mode"""
    _mod._UpdateCamera(camera, mode)


def update_camera_pro(camera: int, movement: Vector3, rotation: Vector3, zoom: float):
    """Update camera movement/rotation"""
    _mod._UpdateCameraPro(camera, movement._address, rotation._address, zoom)


def set_shapes_texture(texture: Texture2D, source: Rectangle):
    """Set texture and rectangle to be used on shapes drawing"""
    _mod._SetShapesTexture(texture._address, source._address)


def draw_pixel(posX: int, posY: int, color: Color):
    """Draw a pixel"""
    _mod._DrawPixel(posX, posY, color._address)


def draw_pixel_v(position: Vector2, color: Color):
    """Draw a pixel (Vector version)"""
    _mod._DrawPixelV(position._address, color._address)


def draw_line(startPosX: int, startPosY: int, endPosX: int, endPosY: int, color: Color):
    """Draw a line"""
    _mod._DrawLine(startPosX, startPosY, endPosX, endPosY, color._address)


def draw_line_v(startPos: Vector2, endPos: Vector2, color: Color):
    """Draw a line (Vector version)"""
    _mod._DrawLineV(startPos._address, endPos._address, color._address)


def draw_line_ex(startPos: Vector2, endPos: Vector2, thick: float, color: Color):
    """Draw a line defining thickness"""
    _mod._DrawLineEx(startPos._address, endPos._address, thick, color._address)


def draw_line_bezier(startPos: Vector2, endPos: Vector2, thick: float, color: Color):
    """Draw a line using cubic-bezier curves in-out"""
    _mod._DrawLineBezier(startPos._address, endPos._address, thick, color._address)


def draw_line_bezier_quad(startPos: Vector2, endPos: Vector2, controlPos: Vector2, thick: float, color: Color):
    """Draw line using quadratic bezier curves with a control point"""
    _mod._DrawLineBezierQuad(startPos._address, endPos._address, controlPos._address, thick, color._address)


def draw_line_bezier_cubic(startPos: Vector2, endPos: Vector2, startControlPos: Vector2, endControlPos: Vector2, thick: float, color: Color):
    """Draw line using cubic bezier curves with 2 control points"""
    _mod._DrawLineBezierCubic(startPos._address, endPos._address, startControlPos._address, endControlPos._address, thick, color._address)


def draw_line_strip(points: int, pointCount: int, color: Color):
    """Draw lines sequence"""
    _mod._DrawLineStrip(points, pointCount, color._address)


def draw_circle(centerX: int, centerY: int, radius: float, color: Color):
    """Draw a color-filled circle"""
    _mod._DrawCircle(centerX, centerY, radius, color._address)


def draw_circle_sector(center: Vector2, radius: float, startAngle: float, endAngle: float, segments: int, color: Color):
    """Draw a piece of a circle"""
    _mod._DrawCircleSector(center._address, radius, startAngle, endAngle, segments, color._address)


def draw_circle_sector_lines(center: Vector2, radius: float, startAngle: float, endAngle: float, segments: int, color: Color):
    """Draw circle sector outline"""
    _mod._DrawCircleSectorLines(center._address, radius, startAngle, endAngle, segments, color._address)


def draw_circle_gradient(centerX: int, centerY: int, radius: float, color1: Color, color2: Color):
    """Draw a gradient-filled circle"""
    _mod._DrawCircleGradient(centerX, centerY, radius, color1._address, color2._address)


def draw_circle_v(center: Vector2, radius: float, color: Color):
    """Draw a color-filled circle (Vector version)"""
    _mod._DrawCircleV(center._address, radius, color._address)


def draw_circle_lines(centerX: int, centerY: int, radius: float, color: Color):
    """Draw circle outline"""
    _mod._DrawCircleLines(centerX, centerY, radius, color._address)


def draw_ellipse(centerX: int, centerY: int, radiusH: float, radiusV: float, color: Color):
    """Draw ellipse"""
    _mod._DrawEllipse(centerX, centerY, radiusH, radiusV, color._address)


def draw_ellipse_lines(centerX: int, centerY: int, radiusH: float, radiusV: float, color: Color):
    """Draw ellipse outline"""
    _mod._DrawEllipseLines(centerX, centerY, radiusH, radiusV, color._address)


def draw_ring(center: Vector2, innerRadius: float, outerRadius: float, startAngle: float, endAngle: float, segments: int, color: Color):
    """Draw ring"""
    _mod._DrawRing(center._address, innerRadius, outerRadius, startAngle, endAngle, segments, color._address)


def draw_ring_lines(center: Vector2, innerRadius: float, outerRadius: float, startAngle: float, endAngle: float, segments: int, color: Color):
    """Draw ring outline"""
    _mod._DrawRingLines(center._address, innerRadius, outerRadius, startAngle, endAngle, segments, color._address)


def draw_rectangle(posX: int, posY: int, width: int, height: int, color: Color):
    """Draw a color-filled rectangle"""
    _mod._DrawRectangle(posX, posY, width, height, color._address)


def draw_rectangle_v(position: Vector2, size: Vector2, color: Color):
    """Draw a color-filled rectangle (Vector version)"""
    _mod._DrawRectangleV(position._address, size._address, color._address)


def draw_rectangle_rec(rec: Rectangle, color: Color):
    """Draw a color-filled rectangle"""
    _mod._DrawRectangleRec(rec._address, color._address)


def draw_rectangle_pro(rec: Rectangle, origin: Vector2, rotation: float, color: Color):
    """Draw a color-filled rectangle with pro parameters"""
    _mod._DrawRectanglePro(rec._address, origin._address, rotation, color._address)


def draw_rectangle_gradient_v(posX: int, posY: int, width: int, height: int, color1: Color, color2: Color):
    """Draw a vertical-gradient-filled rectangle"""
    _mod._DrawRectangleGradientV(posX, posY, width, height, color1._address, color2._address)


def draw_rectangle_gradient_h(posX: int, posY: int, width: int, height: int, color1: Color, color2: Color):
    """Draw a horizontal-gradient-filled rectangle"""
    _mod._DrawRectangleGradientH(posX, posY, width, height, color1._address, color2._address)


def draw_rectangle_gradient_ex(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color):
    """Draw a gradient-filled rectangle with custom vertex colors"""
    _mod._DrawRectangleGradientEx(rec._address, col1._address, col2._address, col3._address, col4._address)


def draw_rectangle_lines(posX: int, posY: int, width: int, height: int, color: Color):
    """Draw rectangle outline"""
    _mod._DrawRectangleLines(posX, posY, width, height, color._address)


def draw_rectangle_lines_ex(rec: Rectangle, lineThick: float, color: Color):
    """Draw rectangle outline with extended parameters"""
    _mod._DrawRectangleLinesEx(rec._address, lineThick, color._address)


def draw_rectangle_rounded(rec: Rectangle, roundness: float, segments: int, color: Color):
    """Draw rectangle with rounded edges"""
    _mod._DrawRectangleRounded(rec._address, roundness, segments, color._address)


def draw_rectangle_rounded_lines(rec: Rectangle, roundness: float, segments: int, lineThick: float, color: Color):
    """Draw rectangle with rounded edges outline"""
    _mod._DrawRectangleRoundedLines(rec._address, roundness, segments, lineThick, color._address)


def draw_triangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color):
    """Draw a color-filled triangle (vertex in counter-clockwise order!)"""
    _mod._DrawTriangle(v1._address, v2._address, v3._address, color._address)


def draw_triangle_lines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color):
    """Draw triangle outline (vertex in counter-clockwise order!)"""
    _mod._DrawTriangleLines(v1._address, v2._address, v3._address, color._address)


def draw_triangle_fan(points: int, pointCount: int, color: Color):
    """Draw a triangle fan defined by points (first vertex is the center)"""
    _mod._DrawTriangleFan(points, pointCount, color._address)


def draw_triangle_strip(points: int, pointCount: int, color: Color):
    """Draw a triangle strip defined by points"""
    _mod._DrawTriangleStrip(points, pointCount, color._address)


def draw_poly(center: Vector2, sides: int, radius: float, rotation: float, color: Color):
    """Draw a regular polygon (Vector version)"""
    _mod._DrawPoly(center._address, sides, radius, rotation, color._address)


def draw_poly_lines(center: Vector2, sides: int, radius: float, rotation: float, color: Color):
    """Draw a polygon outline of n sides"""
    _mod._DrawPolyLines(center._address, sides, radius, rotation, color._address)


def draw_poly_lines_ex(center: Vector2, sides: int, radius: float, rotation: float, lineThick: float, color: Color):
    """Draw a polygon outline of n sides with extended parameters"""
    _mod._DrawPolyLinesEx(center._address, sides, radius, rotation, lineThick, color._address)


def check_collision_recs(rec1: Rectangle, rec2: Rectangle) -> int:
    """Check collision between two rectangles"""
    return_interface = _mod._CheckCollisionRecs(rec1._address, rec2._address)
    return return_interface


def check_collision_circles(center1: Vector2, radius1: float, center2: Vector2, radius2: float) -> int:
    """Check collision between two circles"""
    return_interface = _mod._CheckCollisionCircles(center1._address, radius1, center2._address, radius2)
    return return_interface


def check_collision_circle_rec(center: Vector2, radius: float, rec: Rectangle) -> int:
    """Check collision between circle and rectangle"""
    return_interface = _mod._CheckCollisionCircleRec(center._address, radius, rec._address)
    return return_interface


def check_collision_point_rec(point: Vector2, rec: Rectangle) -> int:
    """Check if point is inside rectangle"""
    return_interface = _mod._CheckCollisionPointRec(point._address, rec._address)
    return return_interface


def check_collision_point_circle(point: Vector2, center: Vector2, radius: float) -> int:
    """Check if point is inside circle"""
    return_interface = _mod._CheckCollisionPointCircle(point._address, center._address, radius)
    return return_interface


def check_collision_point_triangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> int:
    """Check if point is inside a triangle"""
    return_interface = _mod._CheckCollisionPointTriangle(point._address, p1._address, p2._address, p3._address)
    return return_interface


def check_collision_point_poly(point: Vector2, points: int, pointCount: int) -> int:
    """Check if point is within a polygon described by array of vertices"""
    return_interface = _mod._CheckCollisionPointPoly(point._address, points, pointCount)
    return return_interface


def check_collision_lines(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: int) -> int:
    """Check the collision between two lines defined by two points each, returns collision point by reference"""
    return_interface = _mod._CheckCollisionLines(startPos1._address, endPos1._address, startPos2._address, endPos2._address, collisionPoint)
    return return_interface


def check_collision_point_line(point: Vector2, p1: Vector2, p2: Vector2, threshold: int) -> int:
    """Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]"""
    return_interface = _mod._CheckCollisionPointLine(point._address, p1._address, p2._address, threshold)
    return return_interface


def get_collision_rec(rec1: Rectangle, rec2: Rectangle) -> Rectangle:
    Rectangle_ = Rectangle()
    """Get collision rectangle for two rectangles collision"""
    _mod._GetCollisionRec(Rectangle_._address, rec1._address, rec2._address)
    return Rectangle_


def load_image(fileName: str) -> Image:
    Image_ = Image()
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load image from file into CPU memory (RAM)"""
    _mod._LoadImage(Image_._address, fileName_)
    _mod._free(fileName_)
    return Image_


def load_image_raw(fileName: str, width: int, height: int, format: int, headerSize: int) -> Image:
    Image_ = Image()
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load image from RAW file data"""
    _mod._LoadImageRaw(Image_._address, fileName_, width, height, format, headerSize)
    _mod._free(fileName_)
    return Image_


def load_image_anim(fileName: str, frames: int) -> Image:
    Image_ = Image()
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load image sequence from file (frames appended to image.data)"""
    _mod._LoadImageAnim(Image_._address, fileName_, frames)
    _mod._free(fileName_)
    return Image_


def load_image_from_memory(fileType: str, fileData: int, dataSize: int) -> Image:
    Image_ = Image()
    fileType_ = _mod._malloc(len(fileType) + 1)
    _mod.stringToUTF8(fileType, fileType_, len(fileType) + 1)
    """Load image from memory buffer, fileType refers to extension: i.e. '.png'"""
    _mod._LoadImageFromMemory(Image_._address, fileType_, fileData, dataSize)
    _mod._free(fileType_)
    return Image_


def load_image_from_texture(texture: Texture2D) -> Image:
    Image_ = Image()
    """Load image from GPU texture data"""
    _mod._LoadImageFromTexture(Image_._address, texture._address)
    return Image_


def load_image_from_screen() -> Image:
    Image_ = Image()
    """Load image from screen buffer and (screenshot)"""
    _mod._LoadImageFromScreen(Image_._address)
    return Image_


def is_image_ready(image: Image) -> int:
    """Check if an image is ready"""
    return_interface = _mod._IsImageReady(image._address)
    return return_interface


def unload_image(image: Image):
    """Unload image from CPU memory (RAM)"""
    _mod._UnloadImage(image._address)


def export_image(image: Image, fileName: str) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Export image data to file, returns true on success"""
    return_interface = _mod._ExportImage(image._address, fileName_)
    _mod._free(fileName_)
    return return_interface


def export_image_to_memory(image: Image, fileType: str, fileSize: int) -> int:
    fileType_ = _mod._malloc(len(fileType) + 1)
    _mod.stringToUTF8(fileType, fileType_, len(fileType) + 1)
    """Export image to memory buffer"""
    return_interface = _mod._ExportImageToMemory(image._address, fileType_, fileSize)
    _mod._free(fileType_)
    return return_interface


def export_image_as_code(image: Image, fileName: str) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Export image as code file defining an array of bytes, returns true on success"""
    return_interface = _mod._ExportImageAsCode(image._address, fileName_)
    _mod._free(fileName_)
    return return_interface


def gen_image_color(width: int, height: int, color: Color) -> Image:
    Image_ = Image()
    """Generate image: plain color"""
    _mod._GenImageColor(Image_._address, width, height, color._address)
    return Image_


def gen_image_gradient_linear(width: int, height: int, direction: int, start: Color, end: Color) -> Image:
    Image_ = Image()
    """Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient"""
    _mod._GenImageGradientLinear(Image_._address, width, height, direction, start._address, end._address)
    return Image_


def gen_image_gradient_radial(width: int, height: int, density: float, inner: Color, outer: Color) -> Image:
    Image_ = Image()
    """Generate image: radial gradient"""
    _mod._GenImageGradientRadial(Image_._address, width, height, density, inner._address, outer._address)
    return Image_


def gen_image_gradient_square(width: int, height: int, density: float, inner: Color, outer: Color) -> Image:
    Image_ = Image()
    """Generate image: square gradient"""
    _mod._GenImageGradientSquare(Image_._address, width, height, density, inner._address, outer._address)
    return Image_


def gen_image_checked(width: int, height: int, checksX: int, checksY: int, col1: Color, col2: Color) -> Image:
    Image_ = Image()
    """Generate image: checked"""
    _mod._GenImageChecked(Image_._address, width, height, checksX, checksY, col1._address, col2._address)
    return Image_


def gen_image_white_noise(width: int, height: int, factor: float) -> Image:
    Image_ = Image()
    """Generate image: white noise"""
    _mod._GenImageWhiteNoise(Image_._address, width, height, factor)
    return Image_


def gen_image_perlin_noise(width: int, height: int, offsetX: int, offsetY: int, scale: float) -> Image:
    Image_ = Image()
    """Generate image: perlin noise"""
    _mod._GenImagePerlinNoise(Image_._address, width, height, offsetX, offsetY, scale)
    return Image_


def gen_image_cellular(width: int, height: int, tileSize: int) -> Image:
    Image_ = Image()
    """Generate image: cellular algorithm, bigger tileSize means bigger cells"""
    _mod._GenImageCellular(Image_._address, width, height, tileSize)
    return Image_


def gen_image_text(width: int, height: int, text: str) -> Image:
    Image_ = Image()
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Generate image: grayscale image from text data"""
    _mod._GenImageText(Image_._address, width, height, text_)
    _mod._free(text_)
    return Image_


def image_copy(image: Image) -> Image:
    Image_ = Image()
    """Create an image duplicate (useful for transformations)"""
    _mod._ImageCopy(Image_._address, image._address)
    return Image_


def image_from_image(image: Image, rec: Rectangle) -> Image:
    Image_ = Image()
    """Create an image from another image piece"""
    _mod._ImageFromImage(Image_._address, image._address, rec._address)
    return Image_


def image_text(text: str, fontSize: int, color: Color) -> Image:
    Image_ = Image()
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Create an image from text (default font)"""
    _mod._ImageText(Image_._address, text_, fontSize, color._address)
    _mod._free(text_)
    return Image_


def image_text_ex(font: Font, text: str, fontSize: float, spacing: float, tint: Color) -> Image:
    Image_ = Image()
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Create an image from text (custom sprite font)"""
    _mod._ImageTextEx(Image_._address, font._address, text_, fontSize, spacing, tint._address)
    _mod._free(text_)
    return Image_


def image_format(image: int, newFormat: int):
    """Convert image data to desired format"""
    _mod._ImageFormat(image, newFormat)


def image_to_pot(image: int, fill: Color):
    """Convert image to POT (power-of-two)"""
    _mod._ImageToPOT(image, fill._address)


def image_crop(image: int, crop: Rectangle):
    """Crop an image to a defined rectangle"""
    _mod._ImageCrop(image, crop._address)


def image_alpha_crop(image: int, threshold: float):
    """Crop image depending on alpha value"""
    _mod._ImageAlphaCrop(image, threshold)


def image_alpha_clear(image: int, color: Color, threshold: float):
    """Clear alpha channel to desired color"""
    _mod._ImageAlphaClear(image, color._address, threshold)


def image_alpha_mask(image: int, alphaMask: Image):
    """Apply alpha mask to image"""
    _mod._ImageAlphaMask(image, alphaMask._address)


def image_alpha_premultiply(image: int):
    """Premultiply alpha channel"""
    _mod._ImageAlphaPremultiply(image)


def image_blur_gaussian(image: int, blurSize: int):
    """Apply Gaussian blur using a box blur approximation"""
    _mod._ImageBlurGaussian(image, blurSize)


def image_resize(image: int, newWidth: int, newHeight: int):
    """Resize image (Bicubic scaling algorithm)"""
    _mod._ImageResize(image, newWidth, newHeight)


def image_resize_nn(image: int, newWidth: int, newHeight: int):
    """Resize image (Nearest-Neighbor scaling algorithm)"""
    _mod._ImageResizeNN(image, newWidth, newHeight)


def image_resize_canvas(image: int, newWidth: int, newHeight: int, offsetX: int, offsetY: int, fill: Color):
    """Resize canvas and fill with color"""
    _mod._ImageResizeCanvas(image, newWidth, newHeight, offsetX, offsetY, fill._address)


def image_mipmaps(image: int):
    """Compute all mipmap levels for a provided image"""
    _mod._ImageMipmaps(image)


def image_dither(image: int, rBpp: int, gBpp: int, bBpp: int, aBpp: int):
    """Dither image data to 16bpp or lower (Floyd-Steinberg dithering)"""
    _mod._ImageDither(image, rBpp, gBpp, bBpp, aBpp)


def image_flip_vertical(image: int):
    """Flip image vertically"""
    _mod._ImageFlipVertical(image)


def image_flip_horizontal(image: int):
    """Flip image horizontally"""
    _mod._ImageFlipHorizontal(image)


def image_rotate(image: int, degrees: int):
    """Rotate image by input angle in degrees (-359 to 359)"""
    _mod._ImageRotate(image, degrees)


def image_rotate_cw(image: int):
    """Rotate image clockwise 90deg"""
    _mod._ImageRotateCW(image)


def image_rotate_ccw(image: int):
    """Rotate image counter-clockwise 90deg"""
    _mod._ImageRotateCCW(image)


def image_color_tint(image: int, color: Color):
    """Modify image color: tint"""
    _mod._ImageColorTint(image, color._address)


def image_color_invert(image: int):
    """Modify image color: invert"""
    _mod._ImageColorInvert(image)


def image_color_grayscale(image: int):
    """Modify image color: grayscale"""
    _mod._ImageColorGrayscale(image)


def image_color_contrast(image: int, contrast: float):
    """Modify image color: contrast (-100 to 100)"""
    _mod._ImageColorContrast(image, contrast)


def image_color_brightness(image: int, brightness: int):
    """Modify image color: brightness (-255 to 255)"""
    _mod._ImageColorBrightness(image, brightness)


def image_color_replace(image: int, color: Color, replace: Color):
    """Modify image color: replace color"""
    _mod._ImageColorReplace(image, color._address, replace._address)


def load_image_colors(image: Image) -> int:
    """Load color data from image as a Color array (RGBA - 32bit)"""
    return_interface = _mod._LoadImageColors(image._address)
    return return_interface


def load_image_palette(image: Image, maxPaletteSize: int, colorCount: int) -> int:
    """Load colors palette from image as a Color array (RGBA - 32bit)"""
    return_interface = _mod._LoadImagePalette(image._address, maxPaletteSize, colorCount)
    return return_interface


def unload_image_colors(colors: int):
    """Unload color data loaded with LoadImageColors()"""
    _mod._UnloadImageColors(colors)


def unload_image_palette(colors: int):
    """Unload colors palette loaded with LoadImagePalette()"""
    _mod._UnloadImagePalette(colors)


def get_image_alpha_border(image: Image, threshold: float) -> Rectangle:
    Rectangle_ = Rectangle()
    """Get image alpha border rectangle"""
    _mod._GetImageAlphaBorder(Rectangle_._address, image._address, threshold)
    return Rectangle_


def get_image_color(image: Image, x: int, y: int) -> Color:
    Color_ = Color()
    """Get image pixel color at (x, y) position"""
    _mod._GetImageColor(Color_._address, image._address, x, y)
    return Color_


def image_clear_background(dst: int, color: Color):
    """Clear image background with given color"""
    _mod._ImageClearBackground(dst, color._address)


def image_draw_pixel(dst: int, posX: int, posY: int, color: Color):
    """Draw pixel within an image"""
    _mod._ImageDrawPixel(dst, posX, posY, color._address)


def image_draw_pixel_v(dst: int, position: Vector2, color: Color):
    """Draw pixel within an image (Vector version)"""
    _mod._ImageDrawPixelV(dst, position._address, color._address)


def image_draw_line(dst: int, startPosX: int, startPosY: int, endPosX: int, endPosY: int, color: Color):
    """Draw line within an image"""
    _mod._ImageDrawLine(dst, startPosX, startPosY, endPosX, endPosY, color._address)


def image_draw_line_v(dst: int, start: Vector2, end: Vector2, color: Color):
    """Draw line within an image (Vector version)"""
    _mod._ImageDrawLineV(dst, start._address, end._address, color._address)


def image_draw_circle(dst: int, centerX: int, centerY: int, radius: int, color: Color):
    """Draw a filled circle within an image"""
    _mod._ImageDrawCircle(dst, centerX, centerY, radius, color._address)


def image_draw_circle_v(dst: int, center: Vector2, radius: int, color: Color):
    """Draw a filled circle within an image (Vector version)"""
    _mod._ImageDrawCircleV(dst, center._address, radius, color._address)


def image_draw_circle_lines(dst: int, centerX: int, centerY: int, radius: int, color: Color):
    """Draw circle outline within an image"""
    _mod._ImageDrawCircleLines(dst, centerX, centerY, radius, color._address)


def image_draw_circle_lines_v(dst: int, center: Vector2, radius: int, color: Color):
    """Draw circle outline within an image (Vector version)"""
    _mod._ImageDrawCircleLinesV(dst, center._address, radius, color._address)


def image_draw_rectangle(dst: int, posX: int, posY: int, width: int, height: int, color: Color):
    """Draw rectangle within an image"""
    _mod._ImageDrawRectangle(dst, posX, posY, width, height, color._address)


def image_draw_rectangle_v(dst: int, position: Vector2, size: Vector2, color: Color):
    """Draw rectangle within an image (Vector version)"""
    _mod._ImageDrawRectangleV(dst, position._address, size._address, color._address)


def image_draw_rectangle_rec(dst: int, rec: Rectangle, color: Color):
    """Draw rectangle within an image"""
    _mod._ImageDrawRectangleRec(dst, rec._address, color._address)


def image_draw_rectangle_lines(dst: int, rec: Rectangle, thick: int, color: Color):
    """Draw rectangle lines within an image"""
    _mod._ImageDrawRectangleLines(dst, rec._address, thick, color._address)


def image_draw(dst: int, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color):
    """Draw a source image within a destination image (tint applied to source)"""
    _mod._ImageDraw(dst, src._address, srcRec._address, dstRec._address, tint._address)


def image_draw_text(dst: int, text: str, posX: int, posY: int, fontSize: int, color: Color):
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Draw text (using default font) within an image (destination)"""
    _mod._ImageDrawText(dst, text_, posX, posY, fontSize, color._address)
    _mod._free(text_)


def image_draw_text_ex(dst: int, font: Font, text: str, position: Vector2, fontSize: float, spacing: float, tint: Color):
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Draw text (custom sprite font) within an image (destination)"""
    _mod._ImageDrawTextEx(dst, font._address, text_, position._address, fontSize, spacing, tint._address)
    _mod._free(text_)


def load_texture(fileName: str) -> Texture2D:
    Texture2D_ = Texture2D()
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load texture from file into GPU memory (VRAM)"""
    _mod._LoadTexture(Texture2D_._address, fileName_)
    _mod._free(fileName_)
    return Texture2D_


def load_texture_from_image(image: Image) -> Texture2D:
    Texture2D_ = Texture2D()
    """Load texture from image data"""
    _mod._LoadTextureFromImage(Texture2D_._address, image._address)
    return Texture2D_


def load_texture_cubemap(image: Image, layout: int) -> TextureCubemap:
    TextureCubemap_ = TextureCubemap()
    """Load cubemap from image, multiple image cubemap layouts supported"""
    _mod._LoadTextureCubemap(TextureCubemap_._address, image._address, layout)
    return TextureCubemap_


def load_render_texture(width: int, height: int) -> RenderTexture2D:
    RenderTexture2D_ = RenderTexture2D()
    """Load texture for rendering (framebuffer)"""
    _mod._LoadRenderTexture(RenderTexture2D_._address, width, height)
    return RenderTexture2D_


def is_texture_ready(texture: Texture2D) -> int:
    """Check if a texture is ready"""
    return_interface = _mod._IsTextureReady(texture._address)
    return return_interface


def unload_texture(texture: Texture2D):
    """Unload texture from GPU memory (VRAM)"""
    _mod._UnloadTexture(texture._address)


def is_render_texture_ready(target: RenderTexture2D) -> int:
    """Check if a render texture is ready"""
    return_interface = _mod._IsRenderTextureReady(target._address)
    return return_interface


def unload_render_texture(target: RenderTexture2D):
    """Unload render texture from GPU memory (VRAM)"""
    _mod._UnloadRenderTexture(target._address)


def update_texture(texture: Texture2D, pixels: int):
    """Update GPU texture with new data"""
    _mod._UpdateTexture(texture._address, pixels)


def update_texture_rec(texture: Texture2D, rec: Rectangle, pixels: int):
    """Update GPU texture rectangle with new data"""
    _mod._UpdateTextureRec(texture._address, rec._address, pixels)


def gen_texture_mipmaps(texture: int):
    """Generate GPU mipmaps for a texture"""
    _mod._GenTextureMipmaps(texture)


def set_texture_filter(texture: Texture2D, filter: int):
    """Set texture scaling filter mode"""
    _mod._SetTextureFilter(texture._address, filter)


def set_texture_wrap(texture: Texture2D, wrap: int):
    """Set texture wrapping mode"""
    _mod._SetTextureWrap(texture._address, wrap)


def draw_texture(texture: Texture2D, posX: int, posY: int, tint: Color):
    """Draw a Texture2D"""
    _mod._DrawTexture(texture._address, posX, posY, tint._address)


def draw_texture_v(texture: Texture2D, position: Vector2, tint: Color):
    """Draw a Texture2D with position defined as Vector2"""
    _mod._DrawTextureV(texture._address, position._address, tint._address)


def draw_texture_ex(texture: Texture2D, position: Vector2, rotation: float, scale: float, tint: Color):
    """Draw a Texture2D with extended parameters"""
    _mod._DrawTextureEx(texture._address, position._address, rotation, scale, tint._address)


def draw_texture_rec(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color):
    """Draw a part of a texture defined by a rectangle"""
    _mod._DrawTextureRec(texture._address, source._address, position._address, tint._address)


def draw_texture_pro(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: float, tint: Color):
    """Draw a part of a texture defined by a rectangle with 'pro' parameters"""
    _mod._DrawTexturePro(texture._address, source._address, dest._address, origin._address, rotation, tint._address)


def draw_texture_n_patch(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: float, tint: Color):
    """Draws a texture (or part of it) that stretches or shrinks nicely"""
    _mod._DrawTextureNPatch(texture._address, nPatchInfo._address, dest._address, origin._address, rotation, tint._address)


def fade(color: Color, alpha: float) -> Color:
    Color_ = Color()
    """Get color with alpha applied, alpha goes from 0.0f to 1.0f"""
    _mod._Fade(Color_._address, color._address, alpha)
    return Color_


def color_to_int(color: Color) -> int:
    """Get hexadecimal value for a Color"""
    return_interface = _mod._ColorToInt(color._address)
    return return_interface


def color_normalize(color: Color) -> Vector4:
    Vector4_ = Vector4()
    """Get Color normalized as float [0..1]"""
    _mod._ColorNormalize(Vector4_._address, color._address)
    return Vector4_


def color_from_normalized(normalized: Vector4) -> Color:
    Color_ = Color()
    """Get Color from normalized values [0..1]"""
    _mod._ColorFromNormalized(Color_._address, normalized._address)
    return Color_


def color_to_hsv(color: Color) -> Vector3:
    Vector3_ = Vector3()
    """Get HSV values for a Color, hue [0..360], saturation/value [0..1]"""
    _mod._ColorToHSV(Vector3_._address, color._address)
    return Vector3_


def color_from_hsv(hue: float, saturation: float, value: float) -> Color:
    Color_ = Color()
    """Get a Color from HSV values, hue [0..360], saturation/value [0..1]"""
    _mod._ColorFromHSV(Color_._address, hue, saturation, value)
    return Color_


def color_tint(color: Color, tint: Color) -> Color:
    Color_ = Color()
    """Get color multiplied with another color"""
    _mod._ColorTint(Color_._address, color._address, tint._address)
    return Color_


def color_brightness(color: Color, factor: float) -> Color:
    Color_ = Color()
    """Get color with brightness correction, brightness factor goes from -1.0f to 1.0f"""
    _mod._ColorBrightness(Color_._address, color._address, factor)
    return Color_


def color_contrast(color: Color, contrast: float) -> Color:
    Color_ = Color()
    """Get color with contrast correction, contrast values between -1.0f and 1.0f"""
    _mod._ColorContrast(Color_._address, color._address, contrast)
    return Color_


def color_alpha(color: Color, alpha: float) -> Color:
    Color_ = Color()
    """Get color with alpha applied, alpha goes from 0.0f to 1.0f"""
    _mod._ColorAlpha(Color_._address, color._address, alpha)
    return Color_


def color_alpha_blend(dst: Color, src: Color, tint: Color) -> Color:
    Color_ = Color()
    """Get src alpha-blended into dst color with tint"""
    _mod._ColorAlphaBlend(Color_._address, dst._address, src._address, tint._address)
    return Color_


def get_color(hexValue: int) -> Color:
    Color_ = Color()
    """Get Color structure from hexadecimal value"""
    _mod._GetColor(Color_._address, hexValue)
    return Color_


def get_pixel_color(srcPtr: int, format: int) -> Color:
    Color_ = Color()
    """Get Color from a source pixel pointer of certain format"""
    _mod._GetPixelColor(Color_._address, srcPtr, format)
    return Color_


def set_pixel_color(dstPtr: int, color: Color, format: int):
    """Set color formatted into destination pixel pointer"""
    _mod._SetPixelColor(dstPtr, color._address, format)


def get_pixel_data_size(width: int, height: int, format: int) -> int:
    """Get pixel data size in bytes for certain format"""
    return_interface = _mod._GetPixelDataSize(width, height, format)
    return return_interface


def get_font_default() -> Font:
    Font_ = Font()
    """Get the default Font"""
    _mod._GetFontDefault(Font_._address)
    return Font_


def load_font(fileName: str) -> Font:
    Font_ = Font()
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load font from file into GPU memory (VRAM)"""
    _mod._LoadFont(Font_._address, fileName_)
    _mod._free(fileName_)
    return Font_


def load_font_ex(fileName: str, fontSize: int, fontChars: int, glyphCount: int) -> Font:
    Font_ = Font()
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load font from file with extended parameters, use NULL for fontChars and 0 for glyphCount to load the default character set"""
    _mod._LoadFontEx(Font_._address, fileName_, fontSize, fontChars, glyphCount)
    _mod._free(fileName_)
    return Font_


def load_font_from_image(image: Image, key: Color, firstChar: int) -> Font:
    Font_ = Font()
    """Load font from Image (XNA style)"""
    _mod._LoadFontFromImage(Font_._address, image._address, key._address, firstChar)
    return Font_


def load_font_from_memory(fileType: str, fileData: int, dataSize: int, fontSize: int, fontChars: int, glyphCount: int) -> Font:
    Font_ = Font()
    fileType_ = _mod._malloc(len(fileType) + 1)
    _mod.stringToUTF8(fileType, fileType_, len(fileType) + 1)
    """Load font from memory buffer, fileType refers to extension: i.e. '.ttf'"""
    _mod._LoadFontFromMemory(Font_._address, fileType_, fileData, dataSize, fontSize, fontChars, glyphCount)
    _mod._free(fileType_)
    return Font_


def is_font_ready(font: Font) -> int:
    """Check if a font is ready"""
    return_interface = _mod._IsFontReady(font._address)
    return return_interface


def load_font_data(fileData: int, dataSize: int, fontSize: int, fontChars: int, glyphCount: int, type: int) -> int:
    """Load font data for further use"""
    return_interface = _mod._LoadFontData(fileData, dataSize, fontSize, fontChars, glyphCount, type)
    return return_interface


def gen_image_font_atlas(chars: int, recs: int, glyphCount: int, fontSize: int, padding: int, packMethod: int) -> Image:
    Image_ = Image()
    """Generate image font atlas using chars info"""
    _mod._GenImageFontAtlas(Image_._address, chars, recs, glyphCount, fontSize, padding, packMethod)
    return Image_


def unload_font_data(chars: int, glyphCount: int):
    """Unload font chars info data (RAM)"""
    _mod._UnloadFontData(chars, glyphCount)


def unload_font(font: Font):
    """Unload font from GPU memory (VRAM)"""
    _mod._UnloadFont(font._address)


def export_font_as_code(font: Font, fileName: str) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Export font as code file, returns true on success"""
    return_interface = _mod._ExportFontAsCode(font._address, fileName_)
    _mod._free(fileName_)
    return return_interface


def draw_fps(posX: int, posY: int):
    """Draw current FPS"""
    _mod._DrawFPS(posX, posY)


def draw_text(text: str, posX: int, posY: int, fontSize: int, color: Color):
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Draw text (using default font)"""
    _mod._DrawText(text_, posX, posY, fontSize, color._address)
    _mod._free(text_)


def draw_text_ex(font: Font, text: str, position: Vector2, fontSize: float, spacing: float, tint: Color):
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Draw text using font and additional parameters"""
    _mod._DrawTextEx(font._address, text_, position._address, fontSize, spacing, tint._address)
    _mod._free(text_)


def draw_text_pro(font: Font, text: str, position: Vector2, origin: Vector2, rotation: float, fontSize: float, spacing: float, tint: Color):
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Draw text using Font and pro parameters (rotation)"""
    _mod._DrawTextPro(font._address, text_, position._address, origin._address, rotation, fontSize, spacing, tint._address)
    _mod._free(text_)


def draw_text_codepoint(font: Font, codepoint: int, position: Vector2, fontSize: float, tint: Color):
    """Draw one character (codepoint)"""
    _mod._DrawTextCodepoint(font._address, codepoint, position._address, fontSize, tint._address)


def draw_text_codepoints(font: Font, codepoints: int, count: int, position: Vector2, fontSize: float, spacing: float, tint: Color):
    """Draw multiple character (codepoint)"""
    _mod._DrawTextCodepoints(font._address, codepoints, count, position._address, fontSize, spacing, tint._address)


def set_text_line_spacing(spacing: int):
    """Set vertical line spacing when drawing with line-breaks"""
    _mod._SetTextLineSpacing(spacing)


def measure_text(text: str, fontSize: int) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Measure string width for default font"""
    return_interface = _mod._MeasureText(text_, fontSize)
    _mod._free(text_)
    return return_interface


def measure_text_ex(font: Font, text: str, fontSize: float, spacing: float) -> Vector2:
    Vector2_ = Vector2()
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Measure string size for Font"""
    _mod._MeasureTextEx(Vector2_._address, font._address, text_, fontSize, spacing)
    _mod._free(text_)
    return Vector2_


def get_glyph_index(font: Font, codepoint: int) -> int:
    """Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found"""
    return_interface = _mod._GetGlyphIndex(font._address, codepoint)
    return return_interface


def get_glyph_info(font: Font, codepoint: int) -> GlyphInfo:
    GlyphInfo_ = GlyphInfo()
    """Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found"""
    _mod._GetGlyphInfo(GlyphInfo_._address, font._address, codepoint)
    return GlyphInfo_


def get_glyph_atlas_rec(font: Font, codepoint: int) -> Rectangle:
    Rectangle_ = Rectangle()
    """Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found"""
    _mod._GetGlyphAtlasRec(Rectangle_._address, font._address, codepoint)
    return Rectangle_


def load_utf8(codepoints: int, length: int) -> int:
    """Load UTF-8 text encoded from codepoints array"""
    return_interface = _mod._LoadUTF8(codepoints, length)
    return return_interface


def unload_utf8(text: int):
    """Unload UTF-8 text encoded from codepoints array"""
    _mod._UnloadUTF8(text)


def load_codepoints(text: str, count: int) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Load all codepoints from a UTF-8 text string, codepoints count returned by parameter"""
    return_interface = _mod._LoadCodepoints(text_, count)
    _mod._free(text_)
    return return_interface


def unload_codepoints(codepoints: int):
    """Unload codepoints data from memory"""
    _mod._UnloadCodepoints(codepoints)


def get_codepoint_count(text: str) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Get total number of codepoints in a UTF-8 encoded string"""
    return_interface = _mod._GetCodepointCount(text_)
    _mod._free(text_)
    return return_interface


def get_codepoint(text: str, codepointSize: int) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure"""
    return_interface = _mod._GetCodepoint(text_, codepointSize)
    _mod._free(text_)
    return return_interface


def get_codepoint_next(text: str, codepointSize: int) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure"""
    return_interface = _mod._GetCodepointNext(text_, codepointSize)
    _mod._free(text_)
    return return_interface


def get_codepoint_previous(text: str, codepointSize: int) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure"""
    return_interface = _mod._GetCodepointPrevious(text_, codepointSize)
    _mod._free(text_)
    return return_interface


def codepoint_to_utf8(codepoint: int, utf8Size: int) -> int:
    """Encode one codepoint into UTF-8 byte array (array length returned as parameter)"""
    return_interface = _mod._CodepointToUTF8(codepoint, utf8Size)
    return return_interface


def text_copy(dst: int, src: str) -> int:
    src_ = _mod._malloc(len(src) + 1)
    _mod.stringToUTF8(src, src_, len(src) + 1)
    """Copy one string to another, returns bytes copied"""
    return_interface = _mod._TextCopy(dst, src_)
    _mod._free(src_)
    return return_interface


def text_is_equal(text1: str, text2: str) -> int:
    text1_ = _mod._malloc(len(text1) + 1)
    _mod.stringToUTF8(text1, text1_, len(text1) + 1)
    text2_ = _mod._malloc(len(text2) + 1)
    _mod.stringToUTF8(text2, text2_, len(text2) + 1)
    """Check if two text string are equal"""
    return_interface = _mod._TextIsEqual(text1_, text2_)
    _mod._free(text1_)
    _mod._free(text2_)
    return return_interface


def text_length(text: str) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Get text length, checks for '\0' ending"""
    return_interface = _mod._TextLength(text_)
    _mod._free(text_)
    return return_interface


def text_subtext(text: str, position: int, length: int) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Get a piece of a text string"""
    return_interface = _mod._TextSubtext(text_, position, length)
    _mod._free(text_)
    return return_interface


def text_replace(text: int, replace: str, by: str) -> int:
    replace_ = _mod._malloc(len(replace) + 1)
    _mod.stringToUTF8(replace, replace_, len(replace) + 1)
    by_ = _mod._malloc(len(by) + 1)
    _mod.stringToUTF8(by, by_, len(by) + 1)
    """Replace text string (WARNING: memory must be freed!)"""
    return_interface = _mod._TextReplace(text, replace_, by_)
    _mod._free(replace_)
    _mod._free(by_)
    return return_interface


def text_insert(text: str, insert: str, position: int) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    insert_ = _mod._malloc(len(insert) + 1)
    _mod.stringToUTF8(insert, insert_, len(insert) + 1)
    """Insert text in a position (WARNING: memory must be freed!)"""
    return_interface = _mod._TextInsert(text_, insert_, position)
    _mod._free(text_)
    _mod._free(insert_)
    return return_interface


def text_join(textList: int, count: int, delimiter: str) -> int:
    delimiter_ = _mod._malloc(len(delimiter) + 1)
    _mod.stringToUTF8(delimiter, delimiter_, len(delimiter) + 1)
    """Join text strings with delimiter"""
    return_interface = _mod._TextJoin(textList, count, delimiter_)
    _mod._free(delimiter_)
    return return_interface


def text_split(text: str, delimiter: int, count: int) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Split text into multiple strings"""
    return_interface = _mod._TextSplit(text_, delimiter, count)
    _mod._free(text_)
    return return_interface


def text_append(text: int, append: str, position: int):
    append_ = _mod._malloc(len(append) + 1)
    _mod.stringToUTF8(append, append_, len(append) + 1)
    """Append text at specific position and move cursor!"""
    _mod._TextAppend(text, append_, position)
    _mod._free(append_)


def text_find_index(text: str, find: str) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    find_ = _mod._malloc(len(find) + 1)
    _mod.stringToUTF8(find, find_, len(find) + 1)
    """Find first text occurrence within a string"""
    return_interface = _mod._TextFindIndex(text_, find_)
    _mod._free(text_)
    _mod._free(find_)
    return return_interface


def text_to_upper(text: str) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Get upper case version of provided string"""
    return_interface = _mod._TextToUpper(text_)
    _mod._free(text_)
    return return_interface


def text_to_lower(text: str) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Get lower case version of provided string"""
    return_interface = _mod._TextToLower(text_)
    _mod._free(text_)
    return return_interface


def text_to_pascal(text: str) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Get Pascal case notation version of provided string"""
    return_interface = _mod._TextToPascal(text_)
    _mod._free(text_)
    return return_interface


def text_to_integer(text: str) -> int:
    text_ = _mod._malloc(len(text) + 1)
    _mod.stringToUTF8(text, text_, len(text) + 1)
    """Get integer value from text (negative values not supported)"""
    return_interface = _mod._TextToInteger(text_)
    _mod._free(text_)
    return return_interface


def draw_line_3d(startPos: Vector3, endPos: Vector3, color: Color):
    """Draw a line in 3D world space"""
    _mod._DrawLine3D(startPos._address, endPos._address, color._address)


def draw_point_3d(position: Vector3, color: Color):
    """Draw a point in 3D space, actually a small line"""
    _mod._DrawPoint3D(position._address, color._address)


def draw_circle_3d(center: Vector3, radius: float, rotationAxis: Vector3, rotationAngle: float, color: Color):
    """Draw a circle in 3D world space"""
    _mod._DrawCircle3D(center._address, radius, rotationAxis._address, rotationAngle, color._address)


def draw_triangle_3d(v1: Vector3, v2: Vector3, v3: Vector3, color: Color):
    """Draw a color-filled triangle (vertex in counter-clockwise order!)"""
    _mod._DrawTriangle3D(v1._address, v2._address, v3._address, color._address)


def draw_triangle_strip_3d(points: int, pointCount: int, color: Color):
    """Draw a triangle strip defined by points"""
    _mod._DrawTriangleStrip3D(points, pointCount, color._address)


def draw_cube(position: Vector3, width: float, height: float, length: float, color: Color):
    """Draw cube"""
    _mod._DrawCube(position._address, width, height, length, color._address)


def draw_cube_v(position: Vector3, size: Vector3, color: Color):
    """Draw cube (Vector version)"""
    _mod._DrawCubeV(position._address, size._address, color._address)


def draw_cube_wires(position: Vector3, width: float, height: float, length: float, color: Color):
    """Draw cube wires"""
    _mod._DrawCubeWires(position._address, width, height, length, color._address)


def draw_cube_wires_v(position: Vector3, size: Vector3, color: Color):
    """Draw cube wires (Vector version)"""
    _mod._DrawCubeWiresV(position._address, size._address, color._address)


def draw_sphere(centerPos: Vector3, radius: float, color: Color):
    """Draw sphere"""
    _mod._DrawSphere(centerPos._address, radius, color._address)


def draw_sphere_ex(centerPos: Vector3, radius: float, rings: int, slices: int, color: Color):
    """Draw sphere with extended parameters"""
    _mod._DrawSphereEx(centerPos._address, radius, rings, slices, color._address)


def draw_sphere_wires(centerPos: Vector3, radius: float, rings: int, slices: int, color: Color):
    """Draw sphere wires"""
    _mod._DrawSphereWires(centerPos._address, radius, rings, slices, color._address)


def draw_cylinder(position: Vector3, radiusTop: float, radiusBottom: float, height: float, slices: int, color: Color):
    """Draw a cylinder/cone"""
    _mod._DrawCylinder(position._address, radiusTop, radiusBottom, height, slices, color._address)


def draw_cylinder_ex(startPos: Vector3, endPos: Vector3, startRadius: float, endRadius: float, sides: int, color: Color):
    """Draw a cylinder with base at startPos and top at endPos"""
    _mod._DrawCylinderEx(startPos._address, endPos._address, startRadius, endRadius, sides, color._address)


def draw_cylinder_wires(position: Vector3, radiusTop: float, radiusBottom: float, height: float, slices: int, color: Color):
    """Draw a cylinder/cone wires"""
    _mod._DrawCylinderWires(position._address, radiusTop, radiusBottom, height, slices, color._address)


def draw_cylinder_wires_ex(startPos: Vector3, endPos: Vector3, startRadius: float, endRadius: float, sides: int, color: Color):
    """Draw a cylinder wires with base at startPos and top at endPos"""
    _mod._DrawCylinderWiresEx(startPos._address, endPos._address, startRadius, endRadius, sides, color._address)


def draw_capsule(startPos: Vector3, endPos: Vector3, radius: float, slices: int, rings: int, color: Color):
    """Draw a capsule with the center of its sphere caps at startPos and endPos"""
    _mod._DrawCapsule(startPos._address, endPos._address, radius, slices, rings, color._address)


def draw_capsule_wires(startPos: Vector3, endPos: Vector3, radius: float, slices: int, rings: int, color: Color):
    """Draw capsule wireframe with the center of its sphere caps at startPos and endPos"""
    _mod._DrawCapsuleWires(startPos._address, endPos._address, radius, slices, rings, color._address)


def draw_plane(centerPos: Vector3, size: Vector2, color: Color):
    """Draw a plane XZ"""
    _mod._DrawPlane(centerPos._address, size._address, color._address)


def draw_ray(ray: Ray, color: Color):
    """Draw a ray line"""
    _mod._DrawRay(ray._address, color._address)


def draw_grid(slices: int, spacing: float):
    """Draw a grid (centered at (0, 0, 0))"""
    _mod._DrawGrid(slices, spacing)


def load_model(fileName: str) -> Model:
    Model_ = Model()
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load model from files (meshes and materials)"""
    _mod._LoadModel(Model_._address, fileName_)
    _mod._free(fileName_)
    return Model_


def load_model_from_mesh(mesh: Mesh) -> Model:
    Model_ = Model()
    """Load model from generated mesh (default material)"""
    _mod._LoadModelFromMesh(Model_._address, mesh._address)
    return Model_


def is_model_ready(model: Model) -> int:
    """Check if a model is ready"""
    return_interface = _mod._IsModelReady(model._address)
    return return_interface


def unload_model(model: Model):
    """Unload model (including meshes) from memory (RAM and/or VRAM)"""
    _mod._UnloadModel(model._address)


def get_model_bounding_box(model: Model) -> BoundingBox:
    BoundingBox_ = BoundingBox()
    """Compute model bounding box limits (considers all meshes)"""
    _mod._GetModelBoundingBox(BoundingBox_._address, model._address)
    return BoundingBox_


def draw_model(model: Model, position: Vector3, scale: float, tint: Color):
    """Draw a model (with texture if set)"""
    _mod._DrawModel(model._address, position._address, scale, tint._address)


def draw_model_ex(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: float, scale: Vector3, tint: Color):
    """Draw a model with extended parameters"""
    _mod._DrawModelEx(model._address, position._address, rotationAxis._address, rotationAngle, scale._address, tint._address)


def draw_model_wires(model: Model, position: Vector3, scale: float, tint: Color):
    """Draw a model wires (with texture if set)"""
    _mod._DrawModelWires(model._address, position._address, scale, tint._address)


def draw_model_wires_ex(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: float, scale: Vector3, tint: Color):
    """Draw a model wires (with texture if set) with extended parameters"""
    _mod._DrawModelWiresEx(model._address, position._address, rotationAxis._address, rotationAngle, scale._address, tint._address)


def draw_bounding_box(box: BoundingBox, color: Color):
    """Draw bounding box (wires)"""
    _mod._DrawBoundingBox(box._address, color._address)


def draw_billboard(camera: Camera, texture: Texture2D, position: Vector3, size: float, tint: Color):
    """Draw a billboard texture"""
    _mod._DrawBillboard(camera._address, texture._address, position._address, size, tint._address)


def draw_billboard_rec(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color):
    """Draw a billboard texture defined by source"""
    _mod._DrawBillboardRec(camera._address, texture._address, source._address, position._address, size._address, tint._address)


def draw_billboard_pro(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: float, tint: Color):
    """Draw a billboard texture defined by source and rotation"""
    _mod._DrawBillboardPro(camera._address, texture._address, source._address, position._address, up._address, size._address, origin._address, rotation, tint._address)


def upload_mesh(mesh: int, dynamic: int):
    """Upload mesh vertex data in GPU and provide VAO/VBO ids"""
    _mod._UploadMesh(mesh, dynamic)


def update_mesh_buffer(mesh: Mesh, index: int, data: int, dataSize: int, offset: int):
    """Update mesh vertex data in GPU for a specific buffer index"""
    _mod._UpdateMeshBuffer(mesh._address, index, data, dataSize, offset)


def unload_mesh(mesh: Mesh):
    """Unload mesh data from CPU and GPU"""
    _mod._UnloadMesh(mesh._address)


def draw_mesh(mesh: Mesh, material: Material, transform: Matrix):
    """Draw a 3d mesh with material and transform"""
    _mod._DrawMesh(mesh._address, material._address, transform._address)


def draw_mesh_instanced(mesh: Mesh, material: Material, transforms: int, instances: int):
    """Draw multiple mesh instances with material and different transforms"""
    _mod._DrawMeshInstanced(mesh._address, material._address, transforms, instances)


def export_mesh(mesh: Mesh, fileName: str) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Export mesh data to file, returns true on success"""
    return_interface = _mod._ExportMesh(mesh._address, fileName_)
    _mod._free(fileName_)
    return return_interface


def get_mesh_bounding_box(mesh: Mesh) -> BoundingBox:
    BoundingBox_ = BoundingBox()
    """Compute mesh bounding box limits"""
    _mod._GetMeshBoundingBox(BoundingBox_._address, mesh._address)
    return BoundingBox_


def gen_mesh_tangents(mesh: int):
    """Compute mesh tangents"""
    _mod._GenMeshTangents(mesh)


def gen_mesh_poly(sides: int, radius: float) -> Mesh:
    Mesh_ = Mesh()
    """Generate polygonal mesh"""
    _mod._GenMeshPoly(Mesh_._address, sides, radius)
    return Mesh_


def gen_mesh_plane(width: float, length: float, resX: int, resZ: int) -> Mesh:
    Mesh_ = Mesh()
    """Generate plane mesh (with subdivisions)"""
    _mod._GenMeshPlane(Mesh_._address, width, length, resX, resZ)
    return Mesh_


def gen_mesh_cube(width: float, height: float, length: float) -> Mesh:
    Mesh_ = Mesh()
    """Generate cuboid mesh"""
    _mod._GenMeshCube(Mesh_._address, width, height, length)
    return Mesh_


def gen_mesh_sphere(radius: float, rings: int, slices: int) -> Mesh:
    Mesh_ = Mesh()
    """Generate sphere mesh (standard sphere)"""
    _mod._GenMeshSphere(Mesh_._address, radius, rings, slices)
    return Mesh_


def gen_mesh_hemi_sphere(radius: float, rings: int, slices: int) -> Mesh:
    Mesh_ = Mesh()
    """Generate half-sphere mesh (no bottom cap)"""
    _mod._GenMeshHemiSphere(Mesh_._address, radius, rings, slices)
    return Mesh_


def gen_mesh_cylinder(radius: float, height: float, slices: int) -> Mesh:
    Mesh_ = Mesh()
    """Generate cylinder mesh"""
    _mod._GenMeshCylinder(Mesh_._address, radius, height, slices)
    return Mesh_


def gen_mesh_cone(radius: float, height: float, slices: int) -> Mesh:
    Mesh_ = Mesh()
    """Generate cone/pyramid mesh"""
    _mod._GenMeshCone(Mesh_._address, radius, height, slices)
    return Mesh_


def gen_mesh_torus(radius: float, size: float, radSeg: int, sides: int) -> Mesh:
    Mesh_ = Mesh()
    """Generate torus mesh"""
    _mod._GenMeshTorus(Mesh_._address, radius, size, radSeg, sides)
    return Mesh_


def gen_mesh_knot(radius: float, size: float, radSeg: int, sides: int) -> Mesh:
    Mesh_ = Mesh()
    """Generate trefoil knot mesh"""
    _mod._GenMeshKnot(Mesh_._address, radius, size, radSeg, sides)
    return Mesh_


def gen_mesh_heightmap(heightmap: Image, size: Vector3) -> Mesh:
    Mesh_ = Mesh()
    """Generate heightmap mesh from image data"""
    _mod._GenMeshHeightmap(Mesh_._address, heightmap._address, size._address)
    return Mesh_


def gen_mesh_cubicmap(cubicmap: Image, cubeSize: Vector3) -> Mesh:
    Mesh_ = Mesh()
    """Generate cubes-based map mesh from image data"""
    _mod._GenMeshCubicmap(Mesh_._address, cubicmap._address, cubeSize._address)
    return Mesh_


def load_materials(fileName: str, materialCount: int) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load materials from model file"""
    return_interface = _mod._LoadMaterials(fileName_, materialCount)
    _mod._free(fileName_)
    return return_interface


def load_material_default() -> Material:
    Material_ = Material()
    """Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)"""
    _mod._LoadMaterialDefault(Material_._address)
    return Material_


def is_material_ready(material: Material) -> int:
    """Check if a material is ready"""
    return_interface = _mod._IsMaterialReady(material._address)
    return return_interface


def unload_material(material: Material):
    """Unload material from GPU memory (VRAM)"""
    _mod._UnloadMaterial(material._address)


def set_material_texture(material: int, mapType: int, texture: Texture2D):
    """Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)"""
    _mod._SetMaterialTexture(material, mapType, texture._address)


def set_model_mesh_material(model: int, meshId: int, materialId: int):
    """Set material for a mesh"""
    _mod._SetModelMeshMaterial(model, meshId, materialId)


def load_model_animations(fileName: str, animCount: int) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load model animations from file"""
    return_interface = _mod._LoadModelAnimations(fileName_, animCount)
    _mod._free(fileName_)
    return return_interface


def update_model_animation(model: Model, anim: ModelAnimation, frame: int):
    """Update model animation pose"""
    _mod._UpdateModelAnimation(model._address, anim._address, frame)


def unload_model_animation(anim: ModelAnimation):
    """Unload animation data"""
    _mod._UnloadModelAnimation(anim._address)


def unload_model_animations(animations: int, count: int):
    """Unload animation array data"""
    _mod._UnloadModelAnimations(animations, count)


def is_model_animation_valid(model: Model, anim: ModelAnimation) -> int:
    """Check model animation skeleton match"""
    return_interface = _mod._IsModelAnimationValid(model._address, anim._address)
    return return_interface


def check_collision_spheres(center1: Vector3, radius1: float, center2: Vector3, radius2: float) -> int:
    """Check collision between two spheres"""
    return_interface = _mod._CheckCollisionSpheres(center1._address, radius1, center2._address, radius2)
    return return_interface


def check_collision_boxes(box1: BoundingBox, box2: BoundingBox) -> int:
    """Check collision between two bounding boxes"""
    return_interface = _mod._CheckCollisionBoxes(box1._address, box2._address)
    return return_interface


def check_collision_box_sphere(box: BoundingBox, center: Vector3, radius: float) -> int:
    """Check collision between box and sphere"""
    return_interface = _mod._CheckCollisionBoxSphere(box._address, center._address, radius)
    return return_interface


def get_ray_collision_sphere(ray: Ray, center: Vector3, radius: float) -> RayCollision:
    RayCollision_ = RayCollision()
    """Get collision info between ray and sphere"""
    _mod._GetRayCollisionSphere(RayCollision_._address, ray._address, center._address, radius)
    return RayCollision_


def get_ray_collision_box(ray: Ray, box: BoundingBox) -> RayCollision:
    RayCollision_ = RayCollision()
    """Get collision info between ray and box"""
    _mod._GetRayCollisionBox(RayCollision_._address, ray._address, box._address)
    return RayCollision_


def get_ray_collision_mesh(ray: Ray, mesh: Mesh, transform: Matrix) -> RayCollision:
    RayCollision_ = RayCollision()
    """Get collision info between ray and mesh"""
    _mod._GetRayCollisionMesh(RayCollision_._address, ray._address, mesh._address, transform._address)
    return RayCollision_


def get_ray_collision_triangle(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) -> RayCollision:
    RayCollision_ = RayCollision()
    """Get collision info between ray and triangle"""
    _mod._GetRayCollisionTriangle(RayCollision_._address, ray._address, p1._address, p2._address, p3._address)
    return RayCollision_


def get_ray_collision_quad(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) -> RayCollision:
    RayCollision_ = RayCollision()
    """Get collision info between ray and quad"""
    _mod._GetRayCollisionQuad(RayCollision_._address, ray._address, p1._address, p2._address, p3._address, p4._address)
    return RayCollision_


def init_audio_device():
    """Initialize audio device and context"""
    _mod._InitAudioDevice()


def close_audio_device():
    """Close the audio device and context"""
    _mod._CloseAudioDevice()


def is_audio_device_ready() -> int:
    """Check if audio device has been initialized successfully"""
    return_interface = _mod._IsAudioDeviceReady()
    return return_interface


def set_master_volume(volume: float):
    """Set master volume (listener)"""
    _mod._SetMasterVolume(volume)


def load_wave(fileName: str) -> Wave:
    Wave_ = Wave()
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load wave data from file"""
    _mod._LoadWave(Wave_._address, fileName_)
    _mod._free(fileName_)
    return Wave_


def load_wave_from_memory(fileType: str, fileData: int, dataSize: int) -> Wave:
    Wave_ = Wave()
    fileType_ = _mod._malloc(len(fileType) + 1)
    _mod.stringToUTF8(fileType, fileType_, len(fileType) + 1)
    """Load wave from memory buffer, fileType refers to extension: i.e. '.wav'"""
    _mod._LoadWaveFromMemory(Wave_._address, fileType_, fileData, dataSize)
    _mod._free(fileType_)
    return Wave_


def is_wave_ready(wave: Wave) -> int:
    """Checks if wave data is ready"""
    return_interface = _mod._IsWaveReady(wave._address)
    return return_interface


def load_sound(fileName: str) -> Sound:
    Sound_ = Sound()
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load sound from file"""
    _mod._LoadSound(Sound_._address, fileName_)
    _mod._free(fileName_)
    return Sound_


def load_sound_from_wave(wave: Wave) -> Sound:
    Sound_ = Sound()
    """Load sound from wave data"""
    _mod._LoadSoundFromWave(Sound_._address, wave._address)
    return Sound_


def is_sound_ready(sound: Sound) -> int:
    """Checks if a sound is ready"""
    return_interface = _mod._IsSoundReady(sound._address)
    return return_interface


def update_sound(sound: Sound, data: int, sampleCount: int):
    """Update sound buffer with new data"""
    _mod._UpdateSound(sound._address, data, sampleCount)


def unload_wave(wave: Wave):
    """Unload wave data"""
    _mod._UnloadWave(wave._address)


def unload_sound(sound: Sound):
    """Unload sound"""
    _mod._UnloadSound(sound._address)


def export_wave(wave: Wave, fileName: str) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Export wave data to file, returns true on success"""
    return_interface = _mod._ExportWave(wave._address, fileName_)
    _mod._free(fileName_)
    return return_interface


def export_wave_as_code(wave: Wave, fileName: str) -> int:
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Export wave sample data to code (.h), returns true on success"""
    return_interface = _mod._ExportWaveAsCode(wave._address, fileName_)
    _mod._free(fileName_)
    return return_interface


def play_sound(sound: Sound):
    """Play a sound"""
    _mod._PlaySound(sound._address)


def stop_sound(sound: Sound):
    """Stop playing a sound"""
    _mod._StopSound(sound._address)


def pause_sound(sound: Sound):
    """Pause a sound"""
    _mod._PauseSound(sound._address)


def resume_sound(sound: Sound):
    """Resume a paused sound"""
    _mod._ResumeSound(sound._address)


def is_sound_playing(sound: Sound) -> int:
    """Check if a sound is currently playing"""
    return_interface = _mod._IsSoundPlaying(sound._address)
    return return_interface


def set_sound_volume(sound: Sound, volume: float):
    """Set volume for a sound (1.0 is max level)"""
    _mod._SetSoundVolume(sound._address, volume)


def set_sound_pitch(sound: Sound, pitch: float):
    """Set pitch for a sound (1.0 is base level)"""
    _mod._SetSoundPitch(sound._address, pitch)


def set_sound_pan(sound: Sound, pan: float):
    """Set pan for a sound (0.5 is center)"""
    _mod._SetSoundPan(sound._address, pan)


def wave_copy(wave: Wave) -> Wave:
    Wave_ = Wave()
    """Copy a wave to a new wave"""
    _mod._WaveCopy(Wave_._address, wave._address)
    return Wave_


def wave_crop(wave: int, initSample: int, finalSample: int):
    """Crop a wave to defined samples range"""
    _mod._WaveCrop(wave, initSample, finalSample)


def wave_format(wave: int, sampleRate: int, sampleSize: int, channels: int):
    """Convert wave data to desired format"""
    _mod._WaveFormat(wave, sampleRate, sampleSize, channels)


def load_wave_samples(wave: Wave) -> int:
    """Load samples data from wave as a 32bit float data array"""
    return_interface = _mod._LoadWaveSamples(wave._address)
    return return_interface


def unload_wave_samples(samples: int):
    """Unload samples data loaded with LoadWaveSamples()"""
    _mod._UnloadWaveSamples(samples)


def load_music_stream(fileName: str) -> Music:
    Music_ = Music()
    fileName_ = _mod._malloc(len(fileName) + 1)
    _mod.stringToUTF8(fileName, fileName_, len(fileName) + 1)
    """Load music stream from file"""
    _mod._LoadMusicStream(Music_._address, fileName_)
    _mod._free(fileName_)
    return Music_


def load_music_stream_from_memory(fileType: str, data: int, dataSize: int) -> Music:
    Music_ = Music()
    fileType_ = _mod._malloc(len(fileType) + 1)
    _mod.stringToUTF8(fileType, fileType_, len(fileType) + 1)
    """Load music stream from data"""
    _mod._LoadMusicStreamFromMemory(Music_._address, fileType_, data, dataSize)
    _mod._free(fileType_)
    return Music_


def is_music_ready(music: Music) -> int:
    """Checks if a music stream is ready"""
    return_interface = _mod._IsMusicReady(music._address)
    return return_interface


def unload_music_stream(music: Music):
    """Unload music stream"""
    _mod._UnloadMusicStream(music._address)


def play_music_stream(music: Music):
    """Start music playing"""
    _mod._PlayMusicStream(music._address)


def is_music_stream_playing(music: Music) -> int:
    """Check if music is playing"""
    return_interface = _mod._IsMusicStreamPlaying(music._address)
    return return_interface


def update_music_stream(music: Music):
    """Updates buffers for music streaming"""
    _mod._UpdateMusicStream(music._address)


def stop_music_stream(music: Music):
    """Stop music playing"""
    _mod._StopMusicStream(music._address)


def pause_music_stream(music: Music):
    """Pause music playing"""
    _mod._PauseMusicStream(music._address)


def resume_music_stream(music: Music):
    """Resume playing paused music"""
    _mod._ResumeMusicStream(music._address)


def seek_music_stream(music: Music, position: float):
    """Seek music to a position (in seconds)"""
    _mod._SeekMusicStream(music._address, position)


def set_music_volume(music: Music, volume: float):
    """Set volume for music (1.0 is max level)"""
    _mod._SetMusicVolume(music._address, volume)


def set_music_pitch(music: Music, pitch: float):
    """Set pitch for a music (1.0 is base level)"""
    _mod._SetMusicPitch(music._address, pitch)


def set_music_pan(music: Music, pan: float):
    """Set pan for a music (0.5 is center)"""
    _mod._SetMusicPan(music._address, pan)


def get_music_time_length(music: Music) -> float:
    """Get music time length (in seconds)"""
    return_interface = _mod._GetMusicTimeLength(music._address)
    return return_interface


def get_music_time_played(music: Music) -> float:
    """Get current music time played (in seconds)"""
    return_interface = _mod._GetMusicTimePlayed(music._address)
    return return_interface


def load_audio_stream(sampleRate: int, sampleSize: int, channels: int) -> AudioStream:
    AudioStream_ = AudioStream()
    """Load audio stream (to stream raw audio pcm data)"""
    _mod._LoadAudioStream(AudioStream_._address, sampleRate, sampleSize, channels)
    return AudioStream_


def is_audio_stream_ready(stream: AudioStream) -> int:
    """Checks if an audio stream is ready"""
    return_interface = _mod._IsAudioStreamReady(stream._address)
    return return_interface


def unload_audio_stream(stream: AudioStream):
    """Unload audio stream and free memory"""
    _mod._UnloadAudioStream(stream._address)


def update_audio_stream(stream: AudioStream, data: int, frameCount: int):
    """Update audio stream buffers with data"""
    _mod._UpdateAudioStream(stream._address, data, frameCount)


def is_audio_stream_processed(stream: AudioStream) -> int:
    """Check if any audio stream buffers requires refill"""
    return_interface = _mod._IsAudioStreamProcessed(stream._address)
    return return_interface


def play_audio_stream(stream: AudioStream):
    """Play audio stream"""
    _mod._PlayAudioStream(stream._address)


def pause_audio_stream(stream: AudioStream):
    """Pause audio stream"""
    _mod._PauseAudioStream(stream._address)


def resume_audio_stream(stream: AudioStream):
    """Resume audio stream"""
    _mod._ResumeAudioStream(stream._address)


def is_audio_stream_playing(stream: AudioStream) -> int:
    """Check if audio stream is playing"""
    return_interface = _mod._IsAudioStreamPlaying(stream._address)
    return return_interface


def stop_audio_stream(stream: AudioStream):
    """Stop audio stream"""
    _mod._StopAudioStream(stream._address)


def set_audio_stream_volume(stream: AudioStream, volume: float):
    """Set volume for audio stream (1.0 is max level)"""
    _mod._SetAudioStreamVolume(stream._address, volume)


def set_audio_stream_pitch(stream: AudioStream, pitch: float):
    """Set pitch for audio stream (1.0 is base level)"""
    _mod._SetAudioStreamPitch(stream._address, pitch)


def set_audio_stream_pan(stream: AudioStream, pan: float):
    """Set pan for audio stream (0.5 is centered)"""
    _mod._SetAudioStreamPan(stream._address, pan)


def set_audio_stream_buffer_size_default(size: int):
    """Default size for new audio streams"""
    _mod._SetAudioStreamBufferSizeDefault(size)


LIGHTGRAY: Color = Color(200, 200, 200, 255, frozen=True)  # Light Gray
GRAY: Color = Color(130, 130, 130, 255, frozen=True)  # Gray
DARKGRAY: Color = Color(80, 80, 80, 255, frozen=True)  # Dark Gray
YELLOW: Color = Color(253, 249, 0, 255, frozen=True)  # Yellow
GOLD: Color = Color(255, 203, 0, 255, frozen=True)  # Gold
ORANGE: Color = Color(255, 161, 0, 255, frozen=True)  # Orange
PINK: Color = Color(255, 109, 194, 255, frozen=True)  # Pink
RED: Color = Color(230, 41, 55, 255, frozen=True)  # Red
MAROON: Color = Color(190, 33, 55, 255, frozen=True)  # Maroon
GREEN: Color = Color(0, 228, 48, 255, frozen=True)  # Green
LIME: Color = Color(0, 158, 47, 255, frozen=True)  # Lime
DARKGREEN: Color = Color(0, 117, 44, 255, frozen=True)  # Dark Green
SKYBLUE: Color = Color(102, 191, 255, 255, frozen=True)  # Sky Blue
BLUE: Color = Color(0, 121, 241, 255, frozen=True)  # Blue
DARKBLUE: Color = Color(0, 82, 172, 255, frozen=True)  # Dark Blue
PURPLE: Color = Color(200, 122, 255, 255, frozen=True)  # Purple
VIOLET: Color = Color(135, 60, 190, 255, frozen=True)  # Violet
DARKPURPLE: Color = Color(112, 31, 126, 255, frozen=True)  # Dark Purple
BEIGE: Color = Color(211, 176, 131, 255, frozen=True)  # Beige
BROWN: Color = Color(127, 106, 79, 255, frozen=True)  # Brown
DARKBROWN: Color = Color(76, 63, 47, 255, frozen=True)  # Dark Brown
WHITE: Color = Color(255, 255, 255, 255, frozen=True)  # White
BLACK: Color = Color(0, 0, 0, 255, frozen=True)  # Black
BLANK: Color = Color(0, 0, 0, 0, frozen=True)  # Blank (Transparent)
MAGENTA: Color = Color(255, 0, 255, 255, frozen=True)  # Magenta
RAYWHITE: Color = Color(245, 245, 245, 255, frozen=True)  # My own White (raylib logo)

